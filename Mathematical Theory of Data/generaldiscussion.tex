

\documentclass[10pt,a4paper]{article}

\input{thepreamble.tex}

\theoremstyle{remark}
\newtheorem*{lemma*}{Lemma}
\newcommand{\catc}[1][C]{\textbf{#1}}
\newcommand{\catcp}[1][C]{\textbf{#1}'}
\newcommand{\reqt}{\textbf{R}}
\newcommand{\reqtc}[1][\catc]{\reqt_{#1}}
\newcommand{\Fin}{\ensuremath{\textbf{Fin}} }
\newcommand{\Finp}{\ensuremath{\textbf{Finp}} }
\newcommand{\Po}{\ensuremath{\textbf{Po}} }
\newcommand{\fundep}[3]{#2 \xrightarrow{#1} #3}
\newlength{\oldparindent}
\setlength{\oldparindent}{\parindent} % Save \parindent before of change
\setlength{\parskip}{0.5\baselineskip} % Definition of `parskip`
\setlength{\parindent}{0pt}
\newcommand{\ind}{\hspace*{\oldparindent}}
\newcounter{para}
\newcommand\note{\par\ind\refstepcounter{para}\thepara.\space}

\begin{document}
\title{General Theory}

% abstract here for ams

\author{John Cartmell}

\maketitle
\begin{center}
DRAFT
\end{center}

\section{Generalities}
\note
There are many methodologies for describing the structure of data. 
A study of these brings us to many essentially distinct notions of data specification. 
Each data specification is a theory of what is.  
Corresponding to each different notion of data specification is a different notion of theory. 
\note
Data is required for a purpose, generally to describe real world things in some or other context. This constitues an intended useage for a data specification. Of all structurally compliant instances of a data specification some are required for the intended usage and, generally speaking, some not.
Notionally let there be a requirement $R$ that equates to a subset of the set of all compliant data instances 
of a data specification and serving to characterise its intended use. 

\note 
There are two self-complementing principles of good engineering. Firstly, within each particular methodology a data specification should be as constraining as possible of data instances while being general enough for the intended useage; equivalently the corresponding theory should fit as tightly as possible to the facts. Secondly, redundancy of data is to be avoided. This second principle is modulated by computational cost for it would be unreasonable not to hold all prime factors of a number in a data structure on account of them being computable and therefore redundant.

\note
From the two principles we can phrase goodness criteria  for data specifications with respect to requirements $\reqt$
i.e. to intended usages. In the context of relational data design, 3rd, 4th and 5th normal forms (and the representation principle?) are examples of such goodness criteria. 

\note
When viewed abstractly many distinct notions of data specification can be characterised as having
data specifications corresponding to sketches of either categories or $\Po$-enriched categories with some additional structure such as certain limits and/or colimits.

\note
Compliant instances of such data specifications correspond to structure preserving functors from the corresponding category to the category of finite sets $\Fin$ or the category of finite sets and partial functions $\Finp$.

\note
Redundancy of objects or arrows in a sketch corresponds to redundacy of data in instances of a data specification. 
By the second principle it is the goal of data specification to avoid such redundancy. 

\note
Goodness equates to absence of redundancy plus maximal constrainedness to intended useage. Absence of redundancy is a property of a sketch. Maximal constrainedness
is a property of the category $\catc$ generated by the sketch and is relative to a requirement $\reqtc$ where $\reqtc$ is a set of structure preserving functors $D$, $D: \catc \morph \Fin$ (or to $\Finp$, as appropriate).
\newpage
\section{A Case Study -- Data Specification as Sketch of Category}
In this section we consider the implications of maximal constrainedness for the very simplest notion 
of data specification namely \term{sketch of category as data specification}.  Not that this is interesting in and by 
itself but it does establishes a pattern for what is to come inclusive of 3rd, 4th and 5th normal form definitions of relational database theory.
\begin{definition}
If $\catc$ is a category and $\reqtc$ is a set of instances i.e a set of functors $D$, $D: \catc \morph \Fin$ then $\catc$ is 
\term{maximally constrained} to the requirement $\reqtc$ iff for all categories $\catcp$ and for all functors 
$I:\catc \morph \catcp$ such that for all instances $D \in \reqtc$ there exists a functor $D':\catcp \morph \Fin$
such that $I \circ D'=D$, for all functors $F: \catc \morph \Fin$ there exists $F' : \catc \morph \Fin$ such that
$I \circ F'=F$.
\end{definition}


\begin{lemma}
If $\catc$ is a category and $\reqtc$ is a set of instances  and $\catc$ is 
\term{maximally constrained} to the requirement $\reqtc$ then
\begin{enumerate}[(a)]
\item
for all diagrams
$
\begin{array}{c p{0.5cm} c  }
 \Rnode{a}{a}            &&   \Rnode{b}{b}
\end{array} 
$
\ncarc[nodesep=2pt,arcangle=10,offset=2pt]{->}{a}{b}
\alabel{f}
\ncarc[nodesep=2pt,arcangle=-10,offset=-2pt]{->}{a}{b}
\blabel{g}
in $\catc$,  if in all instances $D \in \reqtc$, $D(f)=D(g)$, 
then $f=g$ in $\catc$, and 
\item for all diagrams
$
\begin{array}{c p{0.5cm} c  }
             &&   \Rnode{b}{b} \\[0.01cm]
\Rnode{a}{a} &&                \\[0.01cm] 
             &&   \Rnode{c}{c}         
\end{array} 
$
\ncarr{a}{b}
\alabel{f}
\ncarr{a}{c}
\blabel{g}
in $\catc$, if in all instances $D \in \reqtc$ there exist a unique function $h_D : D(b) \morph D(c)$ such that
$D(f) \circ h_D = D(g)$ then there exists a morphism $h:b \morph c$ in $\catc$ such that $f \circ h = g$ in $\catc$, and
\item for all diagrams
$
\begin{array}{c p{0.5cm} c  }
\Rnode{a}{a} &&                \\[0.01cm] 
             &&   \Rnode{b}{b} \\[0.01cm]
\Rnode{c}{c}         
\end{array} 
$
\ncarr{a}{b}
\alabel{f}
\ncarr{c}{b}
\blabel{g} 
in $\catc$, if in all instances $D \in \reqtc$ there exist a unique function $h_D : D(c) \morph D(a)$ such that
$h_D \circ D(f) = D(g)$ then there exists a morphism $h:c \morph a$ in $\catc$ such that $h \circ f = g$ in $\catc$.
\end{enumerate}
\end{lemma}

\subsection{Condition (b) - Functional Depedencies}
If $\catc$ is a category and $\reqtc$ is a set of instances and if
$
\begin{array}{c p{0.5cm} c  }
             &&   \Rnode{b}{b} \\[0.01cm]
\Rnode{a}{a} &&                \\[0.01cm] 
             &&   \Rnode{c}{c}         
\end{array} 
$
\ncarr{a}{b}
\alabel{f}
\ncarr{a}{c}
\blabel{g}
in $\catc$ 
then if the property that we see in condition (b) holds, namely 
that  in all instances $D \in \reqtc$ there exist a unique function $h_D : D(b) \morph D(c)$ such that
$D(f) \circ h_D = D(g)$, then we shall say that $g$ is functionally dependent on $f$ in  context $\tuple{\catc,\reqtc}$.
The concept of functional dependency was defined by Codd in \cite{Codd} in the context of relational data model. 
Our use of the term here is a sort of prototype that will develop as we evolve through a number of steps from 'data model as sketch of category' to a definition equivalent to Codd's definition.  In relational database theory it is usual
to represent such a functional dependensy as we have here by asserting that 
$$
f \morph g
$$
Note that this use of an $\morph$ notation is independent of our use of $\morph$ as a morphism of a category 
or, for that matter, as an edge in a sketch. We have two uses for $\morph$ then (three if you distingish arrows in sketches from arrows in categories). Any particular use will be unambiguous in context. We can develop this thought a bit further and proceed with the following definition of functional dependency which, because we are 
working at this first stage of evolution (`data specification as sketch of category'), we shall say is sense (1)
of the term.
\begin{definition}
If $\catc$ is a category and $\reqtc$ is a set of instances and if
$
\begin{array}{c p{0.5cm} c  }
             &&   \Rnode{b}{b} \\[0.01cm]
\Rnode{a}{a} &&                \\[0.01cm] 
             &&   \Rnode{c}{c}         
\end{array} 
$
\ncarr{a}{b}
\alabel{f}
\ncarr{a}{c}
\blabel{g}
in $\catc$ 
then, in sense (1), a \term{functional dependency} $\fundep{H}{f}{g}$ is a family of functions $H_D)_{D \in \reqtc}$ such that in each instance $D$, $H_D$ is a unique function $H_D: D(a) \morph D(b)$, such that $D(f) \circ H_D = D(g)$.
\end{definition}

\begin{lemma*}
If $\catc$ is a category and $\reqtc$ is a set of instances and $\catc$ is tight to $\reqtc$
then if
$
\begin{array}{c p{0.5cm} c  }
             &&   \Rnode{b}{b} \\[0.01cm]
\Rnode{a}{a} &&                \\[0.01cm] 
             &&   \Rnode{c}{c}         
\end{array} 
$
\ncarr{a}{b}
\alabel{f}
\ncarr{a}{c}
\blabel{g}
in $\catc$ and if there is a functional dependency $\fundep{H}{f}{g}$ with respect to $\tuple{\catc,\reqtc}$ then 
$f$ is an epimorphism in $\catc$.\commentary{Check}
\end{lemma*}
\begin{proof}
Suppose 
\rule[-0.5cm]{0pt}{0.5cm} %to add vertical space below diagrm
$
\begin{array}{c p{0.5cm} c p{0.5cm} c}
\Rnode{a}{a} &&   \Rnode{b}{b} &&   \Rnode{c}{c} 
\end{array} 
$
\ncarr{a}{b}
\alabel{f}
\ncarc[nodesep=2pt,arcangle=10,offset=2pt]{->}{b}{c}
\alabel{h_1}
\ncarc[nodesep=2pt,arcangle=-10,offset=-2pt]{->}{b}{c}
\blabel{h_2}
in $\catc$ and suppose that $f \circ h_1=f \circ h_2$, then in each instance 
 $D \in \reqtc$, $D(f) \circ D(h_1) = D(f) \circ D(h_2)$ but $D(h_1)$ is a unique function such that
$D(f) \circ D(h_1) = D(f \circ h_1)$ and therefore $D(h_1)=D(h_2)$. We have shown that in each instance $D \in \reqtc$, 
$D(h_1)=D(h_2)$ and so since we have assumed $\catc$ is tight to $\reqtc$  by condition (a) of tightness it
follows that $h_1=h_2$. We have shown therefore that $f$ is a epimorphism.
\end{proof}

\subsection{Condition (c) - Inclusion Dependencies}

From condition (c) we define an inclusion dependency in sense (1) as follows:
\begin{definition}
If $\catc$ is a category and $\reqtc$ is a set of instances and if
$
\begin{array}{c p{0.5cm} c  }
\Rnode{a}{a} &&                \\[0.01cm] 
             &&   \Rnode{b}{b} \\[0.01cm]
\Rnode{c}{c}         
\end{array} 
$
\ncarr{a}{b}
\alabel{f}
\ncarr{c}{b}
\blabel{g} 
in $\catc$, then an inclusion dependency in sense (1) $I$, written $c[g] \overset{I}{\subseteq} a[f]$, is a family of functions $I_D)_{D \in \reqtc}$
such that each instance $D \in \reqtc$ $I_D$ is a unique function $I_D : D(c) \morph D(a)$ such that
$I_D \circ D(f) = D(g)$.
\end{definition}

Similar to the above (where)  we can show:

\begin{lemma*}
If $\catc$ is a category and $\reqtc$ is a set of instances and $\catc$ is tight to $\reqtc$
then if $
\begin{array}{c p{0.5cm} c  }
\Rnode{a}{a} &&                \\[0.01cm] 
             &&   \Rnode{b}{b} \\[0.01cm]
\Rnode{c}{c}         
\end{array} 
$
\ncarr{a}{b}
\alabel{f}
\ncarr{c}{b}
\blabel{g} 
in $\catc$ and if there is an inclusion dependency $c[g] \overset{I}{\subseteq} a[f]$ with respect to $\tuple{\catc,\reqtc}$ then $f$ is a monomorphism.
\end{lemma*}

\section*{Data Specification as Sketch of Category with  Monomorphisms}
\section*{Data Specification as Sketch of Category with Products and Monomorphisms}
\section*{Data Specification as Sketch of Category with Limits (and Monomorphisms)}
\section*{Data Specification as Sketch of $\Po$-enriched Category}

\end{document}
