%\documentclass[prodmode,acmtods]{acmsmall}
\documentclass[10pt,a4paper]{article}
\input{../SharedMacros/ccategories.macros}
\input{../SharedMacros/ermacros}
\input{../SharedMacros/erdiagram}
\input{../SharedMacros/theorems.macros}
%\input{../SharedMacros/JCMacros}
\usepackage{mathtools}
\usepackage{alltt}
\usepackage{mnsymbol}
\usepackage{cmll}
\usepackage{ulem}
\renewcommand{\ttdefault}{txtt}
\usepackage[left=1.5cm, right=4cm, marginparwidth=3cm, top=2cm, bottom=1.5cm]{geometry}
\usepackage[font=small]{caption}
\setlength{\captionmargin}{2cm}

\newcommand{\simplepath}[2]{
\ncline[linestyle=dotted,linewidth=0.1pt]{#1}{#2}
\ncput[npos=0.05]{\pnode{dot#21}}
\ncput[npos=0.27]{\dotnode[dotsize=1pt]{dot#22}}
\ncput[npos=0.50]{\dotnode[dotsize=1pt]{dot#23}}
\ncput[npos=0.80]{\dotnode[dotsize=1pt]{dot#24}}
\ncput[npos=0.975]{\pnode{dot#25}}
\ncline[nodesep=3pt]{->}{dot#21}{dot#22}
\ncline[nodesep=3pt]{->}{dot#22}{dot#23}
\ncline[nodesep=3pt]{->}{dot#24}{dot#25}
\ncline[linestyle=dotted,nodesep=10pt]{dot#23}{dot#24}
}

\newcommand{\simplepatha}[3]{
\simplepath{#2}{#3}
\naput[labelsep=1pt]{#1}
}

\newcommand{\simplepathb}[3]{
\simplepath{#2}{#3}
\nbput[labelsep=1pt]{#1}
}
\newcommand{\term}[1]{\textit{{#1}}}
\newcommand{\genericmodel}{\mathcal{M}}
\newcommand{\logtophys}{\mathcal{X}}
\newcommand{\chen}{\mathcal{X}_0}
\newcommand{\chengenericmodel}{\chen(\genericmodel)}
\newcommand{\chigenericmodel}{\logtophys(\genericmodel)}
\newcommand{\allEdges}{\genericmodel^E}
\newcommand{\allAttrs}{\genericmodel^A}
\newcommand{\allRels}{\genericmodel^R}
\newcommand{\edges}[1]{\allEdges_{#1}}
\newcommand{\attrs}[1]{\allAttrs_{#1}}
\newcommand{\rels}[1]{\allRels_{#1}}
\newcommand{\allIdentifying}{\genericmodel^{iE}}
\newcommand{\allIdAttrs}{\genericmodel^{iA}}
\newcommand{\allIdRels}{\genericmodel^{iR}}
\newcommand{\idEdges}[1]{\allIdentifying_{\raisebox{2pt}{$\scriptstyle{#1}$}}}
\newcommand{\idAttrs}[1]{\allIdAttrs_{\raisebox{2pt}{$\scriptstyle{#1}$}}}
\newcommand{\idRels}[1]{\allIdRels_{\raisebox{2pt}{$\scriptstyle{#1}$}}}
\newcommand{\allMandatory}{\allEdges^m}
\newcommand{\allMAttrs}{\allAttrs^m}
\newcommand{\allMRels}{\allRels^m}
\newcommand{\mEdges}[1]{\allIdentifying_{\raisebox{2pt}{$\scriptstyle{#1}$}}}
\newcommand{\mAttrs}[1]{\allIdAttrs_{\raisebox{2pt}{$\scriptstyle{#1}$}}}
\newcommand{\mRels}[1]{\allIdRels_{\raisebox{2pt}{$\scriptstyle{#1}$}}}
\newcommand{\chenAttrs}[1]{\chen(\genericmodel)^A_{#1}}
\newcommand{\chenFKattrs}[1]{\chen(\genericmodel)^{A+}_{#1}}
\newcommand{\chenIdAttrs}[1]{\chen(\genericmodel)^{iA}_{\raisebox{2pt}{$\scriptstyle{#1}$}}}
\newcommand{\chenFKidAttrs}[1]{\chen(\genericmodel)^{iA+}_{\raisebox{2pt}{$\scriptstyle{#1}$}}}
\newcommand{\chiOne}[1]{{\mathcal{X}_1}(\genericmodel)^{A+}_{#1}}
\newcommand{\chiOneId}[1]{{\mathcal{X}_1}(\genericmodel)^{iA+}_{#1}}
\newcommand{\chenFKclasses}[1]{{\mathcal{X}_2}(\genericmodel)^{A+}_{#1}}
\newcommand{\chenFKidClasses}[1]{{\mathcal{X}_2}(\genericmodel)^{iA+}_{#1}}
\newcommand{\chiAttrs}[1]{\logtophys(\genericmodel)^A_{#1}}
\newcommand{\chiFKattrs}[1]{\logtophys(\genericmodel)^{A+}_{#1}}
\newcommand{\chiIdAttrs}[1]{\logtophys(\genericmodel)^{iA}_{\raisebox{2pt}{$\scriptstyle{#1}$}}}
\newcommand{\chiFKidAttrs}[1]{\logtophys(\genericmodel)^{iA+}_{\raisebox{2pt}{$\scriptstyle{#1}$}}}
\newcommand{\Vtype}{v}
\newcommand{\idAttrsDep}[1]{\allIdentifying_{p_#1}}
\newcommand{\idAttrsFromRefs}[1]{\bigcup_{r \in \idRels{#1} }{\srcattrs{r}}}
\newcommand{\destattrs}[1]{\mathbb{D}_{#1}}
\newcommand{\srcattrs}[1]{\mathbb{S}_{#1}}


\begin{document}
\title{Documenting commutative diagrams of relationships to eliminate sources of redundancy in relational data design - Part Two - Logical to Physical Mathematically}
% abstract here for ams

\author{John Cartmell}

\maketitle
\begin{center}
DRAFT \marginpar{\footnotesize Dated 2016 with margin notes 21 Feb 2019. }
      \marginpar{\footnotesize Further variant definitions, notes and  corrections 25/29 April 2019.}
\end{center}


\section{Introduction}

\noindent According to the functional view of data, the content of a 
database instance can be described as a collection of sets 
and functions in that (i) for each entity type $a$ there is defined in 
the database instance a set $E_a$ of entities of type $a$;
(ii) for each, possibly optional, 
many-one relationship $a \overset{r}{\rightpitchfork \hspace{-0.35em} -}b$
there is defined a possibly partial function $f_r : E_a \rightarrow E_b$. 
In this view, an instance of such a relationship $r$ is defined to be a pair 
of entities $e,e'$ such that $f_r(e)=e'$. Without loss of generality
there can be assumed a single set $V$ of all values 
that potentially might be held in columns of tables, 
such as all possible texts, numerics, booleans and so on,
so that for each attribute $attr$
of entity type $et$ there is defined in the database instance a function
$f_{attr}: E_{et} \rightarrow V$. \\

\noindent 
In relational data modelling, each row of data is uniquely distinguishable from the values of a specific set of columns said to 
comprise the primary key to the data whereas in logical entity relationship (ER) modelling each entity is distinguishable from the values of a specific set of attributes taken in combination with a specific set of relationships with other entities\footnote{Whichever methodology is followed the goal is to achieve for the database instances the logical principal of identity of indiscernibles.}. \\

\noindent
From this starting position we provide a set of general definitions of \term{ER schema}, \term{ER schema instance},
\marginpar{\footnotesize is there a use somewhere for the terms \textit{logically redundant} and \textit{physically redundant}?}
and \term{ER model} so that from the definition of \term{ER model} we capture the notion of a database schema 
and all its envisaged usages (to a meta-mathematician the ER schema notion equates to a \term{theory} of some kind
and an ER model to a theory and all its instances i.e. all its models\footnote{This is my first and last usage of the term \term{model} 
with the meaning the term has in mathematical logic; for the remainder of this paper it will have the meaning as used in data modelling.}).  We define the conditions  for an ER model to be purely \term{logical} in the sense used in
the term \term{logical data design} and, in contrast, the conditions for an ER model to be \term{physical}. The definitions are such that
a \term{physical ER model} is pretty much the same thing as a  relational database schema. We define the first-cut Chen mapping for generating a first 
cut physical ER model from a logical ER model and then develop this definition in a way that reduces redundancy in the generated physical model by taking account of commuting and near commuting diagrams of relationships in the logical model
and thereby establish a revised Chen mapping $\logtophys$ so that for any logical ER model $\genericmodel$, $\logtophys(\genericmodel)$ is a physical ER model. Finally we define what it is for a logical model to be well-formulated and prove that if $\genericmodel$ is a well-formulated logical ER model then 
the generated physical ER model $\logtophys(\genericmodel)$ is in Boyce-Codd normal form (BCNF).   


\section{Definition of ER model}
The functional view of data summarised above taken with the requirement of specifying the attributes and relationships from which entitites may be identified suggests a mathematical definition of an ER-schema  as  follows:

\begin{definition}
An \term{ER-schema} is a directed graph having the following additional structure:

\begin{enumerate} [(i)]
\item{a distinguished node $\Vtype$ for which there are no outgoing edges and which represents the type of all scalar values }

\item{a distinguished subset  of edges representing identifying edges.  
}
\end{enumerate}
\end{definition}

\noindent If $\genericmodel$ is an ER-schema (or an ER-model which, as we define below, 
includes an ER-schema) then the nodes of $\genericmodel$ other than $\Vtype$ we say are entity types and we denote by $\edges{a}$, the set of edges leaving entity type $a$. \\

\noindent
The set $\attrs{a}$ of attributes of an entity type $a$ is defined as the set of edges that have $a$ as source and  $\Vtype$ as destination. The set $\rels{a}$ of outgoing relationships of an entity type $a$ is defined as the set of edges having $a$ as source and having destinations other than $\Vtype$.
\noindent Therefore for all entity types $a$:
$$
\edges{a} = \attrs{a} \cup \rels{a}
$$

\noindent That subset of outgoing relationships of $a$ that are also in the distinguished set of identifying edges is said 
be the set of identifying relationships of $a$ and is  denoted $\idRels{a}$. \\

\noindent That subset of those attributes of $a$ that are also in the distinguished set of identifying edges is said 
to be the set of identifying attributes of $a$  and is denoted $\idAttrs{a}$.\\

\noindent The set of all outgoing identifying edges from a node $a$ will be denoted $\idEdges{a}$ \marginpar{\footnotesize Previously $\kappa_a$}. \\

\noindent So that we can define the characteristics of $\idEdges{a}$ as a set of identifying properties for entitites of type
$a$ we need the following definition:

\begin{definition}
If $s$ is a set and if $f_{i, 1\leq i \leq n}$ is a family of partial functions, $f_i: s \rightarrow s_i$   for some sets $s_{i, 1 \leq i \leq n}$,  then
we will say that the family of functions $f_{i, 1\leq i \leq n}$, is \term{jointly injective} if the partial function $\langle f_1,...f_n\rangle: s \rightarrow
s_1 \times ... \times s_n $ is injective. In this case the partial function $\langle f_1,...f_n\rangle: s \rightarrow
s_1 \times ... \times s_n $ is also invertible i.e. iff there is a partial function $inv_{\langle f_1,...f_n\rangle} : s_1 \times ... \times s_n \rightarrow s$ such that
(i) for all $x \in s$, $inv_{\langle f_1,...f_n\rangle}(\langle f_1(x),...f_2(x) \rangle ) = x$ and (ii) if $y \in s_1 \times ... \times s_n $ and
$y \notin img(\langle f_1,...f_n\rangle)$ then $inv_{\langle f_1,...f_n\rangle}(y)$ is undefined. \\
\end{definition}
\noindent The notion of a database instance is defined as follows:
\begin{definition}
\noindent A \term{database instance}  of an ER schema is
a set of entities $E_a$ for each node $a$ of the graph of the schema and 
a partial function $E_r : E_a \rightarrow E_b$ for each edge of the graph $r:a \rightarrow b$ such that 
for each entity type $a$ the family of functions $E_{r, r \in \idEdges{a}}$, is jointly injective. 
\end{definition}

\noindent It follows that in every database instance $E$, for every entity type $a$ there is a function 
$inv_{E_{\idEdges{a}}}$ that represents navigation to an entity from an identifying set of related entities or attributes. 
In a physical model this will equate to keyed lookup. \\

\noindent Without change to the underlying concept then we can say that each ER schema comes equipped with a multi-edge $I_a$ for every entity type a such that if 
the outgoing identifying edges of $a$ are $k_i: a \rightarrow a_i$, for $1 \leq i \leq n$  then the multi-edge has source nodes $\langle a_1,...a_n\rangle$ and destination node $a$.  

\noindent A simple navigation path over an ER model  is a
sequence of  $n$ edges:
$\overset{r_1}{et_0 \rightpitchfork \hspace{-0.35em} -  et_1} \overset{r_2}{\rightpitchfork \hspace{-0.35em} -} et_2 ... \overset{r_n}{\rightpitchfork \hspace{-0.35em} -} et_n$.  $et_0$ is said to be the source of the path and $et_n$ is said to be the destination of the path. 

\noindent We extend this definition to take account of navigation along the multi-edges. To do so we define the set of navigation paths recursively:

\begin{enumerate} [(i)]
\item{ Each edge $f: a \rightarrow b$ is a navigation path.
}
\item{ The empty sequence  $\langle \rangle : a \rightarrow a$ is a navigation path for every entity type $a$.
}
\item{ $\langle p,f \rangle : a \rightarrow c$ is a navigation path  if $p$ is a navigation path $p: a \rightarrow b$ and $f $is an edge $p: b \rightarrow c$
}
\item{ $\langle p_1,...p_n,I_b\rangle : a \rightarrow b$ is a navigation path for all entity types $b$ such that $I_b: \langle b_1,...b_n\rangle$ and where
for each $i$, $1 \leq i \leq n$, $p_i$ is a path, $p_i: a \rightarrow b_i$.   
}
\end{enumerate}

\noindent For any database instance $E$ we can  extend  the definition of
$E_f$, for edges $f$,  so that to every path $p$, $p: a \rightarrow b$,  we have defined a function $E_p: E_a \rightarrow E_b$. From the initial definition of $E_f$ that applies to 
edges the definition proceeds recursively as follows: 
\begin{enumerate} [(i)]
\item{  For each entity type $a$, $E_{\langle \rangle}: E_a \rightarrow E_a$ is defined to be the identity function.
}

\item{   if $p$ is a navigation path $p: a \rightarrow b$ and $f$ is an edge $p: b \rightarrow c$ then $E_{\langle p,f \rangle}$ is 
is defined to be the functional composition $E_p \circ E_f$.
}

\item{ for all entity types $b$ such that $I_b: \langle b_1,...b_n\rangle \rightarrow b$ and where
for each $i$, $1 \leq i \leq n$, $p_i$ is a path, $p_i: a \rightarrow b_i$, $E_{\langle p_1,...p_n,I_b\rangle}$ is defined to be 
$\langle E_{p1},...E_{p_n} \rangle \circ inv_{E_{\idEdges{b}}}$.
}
\end{enumerate}

\noindent If $r$ and $s$ are paths both having source $a$ and destination $b$ then we will say $r \leq s$ iff in all instances E, for all 
entities $e \in E_a$, if $E_r(e)$ is defined then $E_s(e)$ is defined and $E_r(e)=E_s(e)$. \\

\noindent If $r$ and $s$ are paths both having source $a$ and destination $b$ then we will say $r \simeq s$ iff $r \leq s$ and $s \leq r$. \\

\noindent With these definitions,  the (meta-relationship) $\leq$ is a partial order on the classes of equivalent paths. \\

\noindent For paths $r$ and $s$ we define $r < s$ to be equivalent to $r \leq s$ and not $r \simeq s$. \\

\begin{definition}
\noindent An \term{ER model} is an ER schema and a set of database instances of the schema. \\
\end{definition}

\noindent If $p$ is a path within an ER model $\genericmodel$ then say that the path is \term{explicitly represented} wrt the model iff it is equivalent to a simple path. \\

\noindent We generalise the relational data model concept of a candidate key as follows:

\begin{definition}
A family of paths $p_i: a \rightarrow a_i$ within a model $\genericmodel$ is said to be \term{jointly monomorphic} iff in all instances E,
the family of functions 
$E_{p_i, 1 \leq i \leq n}$  is jointly injective. 
\end{definition}

\noindent
Consider that the various database normal forms (3NF, BCNF, 4NF, 5NF and the like) each 
prescribe that a database schema be complete in some way as a description of the facts of its instances\footnote{Essentially
 because being good as a schema is to be a good theory and a good theory is one that is a good fit to the facts.} and observe 
in particular that BCNF can be paraphrased as saying that those relationships (i.e. functional dependencies) that exist in the data ought to be \term{represented} in the schema\footnote{21/02/2019 Is this not the representation principle?}. These considerations motivate the definitions which now follow and conclude with the definition of a \term{well-formulated} entity model. This definition generalises that of a relational schema being in Boyce-Codd Normal Form (BCNF). 
   
\noindent \textbf{Notation}
If $X_1,...X_n$ are sets and if $J=\{i_1,...i_j\} \subseteq \{1,...n\}$ then denote by $P_J$ the projection function :
$$
P_J : X_1 \times X_2 \times ...X_n \rightarrow X_{i_1} \times X_{i_2} \times ... X_{i_j}
$$
\noindent i.e. the function given by:
$$
P_J(\langle x_1,...x_n \rangle ) = \langle x_{i_1},...x_{i_j} \rangle.
$$

\begin{definition}
If $\genericmodel$ is an entity model, if $b_1,...b_n$ and $c$ are entity types of model $\genericmodel$  and if $f_E$ is a family of functions 
such that in every instance $E$ of $\genericmodel$:
$$
f_E : E_{b_1} \times ... \times E_{b_n} \rightarrow E_c
$$
then 
\begin {itemize}
\item{the family of functions $f_E$ is said to be \term{reducible} to a family of functions:
$$
g_E : E_{b_{i_1}} \times ... \times E_{b_{i_j}} \rightarrow E_c
$$
for some $J=\{i_1,...i_j\} \subseteq \{1,...n\}$, iff in all instances E:
$$
f_E = P_J \circ g_E
$$
}
\item{
the family of functions $f_E$ is said to be \term{irreducible} iff there is no proper subset
 $J=\{i_1,...i_j\} \subset \{1,...n\}$, and no family of functions 
$g_E : E_{b_{i_1}},...E_{b_{i_j}} \rightarrow E_c$ such that $f_E$ is reducible to $g_E$.
}
\end{itemize}
\end{definition}

\begin{definition}
A tuple of simple paths $\langle p_1,...p_n \rangle$ is said to be an 
\term{identifying tuple with respect to an entity type $a$}
iff it is in the set of tuples defined recursively as follows:
\begin{enumerate}[(i)]
\item{
the empty tuple $\langle \rangle$ is an identifying tuple with respect to $a$,
}

\item{
if $k_i$, $1 \leq i \leq n$ is the set of all identifying outgoing edges of $a$ then
$\langle \langle k_1 \rangle ,... \langle k_n \rangle \rangle$ is an identifying tuple with respect to $a$,
}

\item{
if $\langle p_1,...p_n \rangle$ is an identifying tuple with respect to $a$ and if for some $i$, $1 \leq i \leq n$, the
destination of $p_i$ is $b$ and if $k_j$, $1 \leq j \leq m$ is the set of all identifying outgoing edges of $b$
then $\langle p_1,...p_{i-1},\langle p_i,k_1 \rangle ... \langle p_i,k_m \rangle, p_{i+1},...p_n \rangle$ is an identifying tuple with respect to $a$.
}

\end{enumerate}

\end{definition}


\begin{definition}
If $\genericmodel$ is an entity model, 
if $a$ and $b$ are entity types of  $\genericmodel$ and  if $\langle q_1,...q_n \rangle$
is an identifying tuple with respect to $b$
 where for each $i$, $q_i: b \rightarrow b_i$,
if  $f_i: a \rightarrow b_i$,  for each $i$,  $1 \leq i \leq n$, is a tuple of edges of $\genericmodel$ 
then say that $\langle f_1,...f_n \rangle$ \term{references $b$ with respect to $\langle q_1,...q_n \rangle$} iff in all instances $E$ of $\genericmodel$,
$img(E_{\langle f_1,...f_n \rangle}) \subseteq img(E_{\langle q_1,...q_n \rangle})$. 
\end{definition}

\begin{definition}
\noindent If $\genericmodel$ is an entity model and if $b_1,...b_n$ and $c$ are entity types within $\genericmodel$ 
and if $f_E$ is a family of functions such that for each instance 
$E$ of $\genericmodel$, 
$f_E: E_{b_1} \times ... \times E_{b_n} \rightarrow E_c$, then the family of functions $f_E$ is \term{represented} in the ER model iff 
either
\begin{enumerate}[(i)]
\item{the family $f_E$ is irreducible and there exists an entity type $d$ and 
an identifying tuple of simple paths with respect to
$d$, $\langle q1,...q_n \rangle$, such that for each $q_i:d \rightarrow b_i$ and a simple
path $z=\langle z_1,...z_l \rangle$ such that $z:d\rightarrow c$, for some $l \geq 0$ as here:

\setlength{\arraycolsep}{.2cm}
\begin{center}
$
\begin{array}{ccp{2cm}c}
\Rnode{b1}{b_1}  &         & &              \\ [0.5cm]
\Rnode{b2}{b_2}  &         & &              \\ [0.2cm]
                 & \vdots  & &              \\ [0.0cm]
\Rnode{bn}{b_n}  &         & & \Rnode{d}{d} \\ [1.0cm]
\Rnode{c}{c}     &         & &              \\
\end{array}
$
\simplepathb{$q_1$}{d}{b1}
\simplepathb{$q_2$}{d}{b2}
\simplepathb{$q_n$}{d}{bn}
\simplepatha{$z$}{d}{c}
\end{center}

where $z_1$ not identifying  and such that in all instances $E$, $inv_{E_{\langle q_1,...q_n\rangle}}\circ E_{\langle z_1,...z_l \rangle} = f_E$
\marginpar{\footnotesize This is equivalent to $f_E=E(\tuple{I_{\tuple{q_1...q_n}},z_1,...z_n})$.}
\begin{center}
$
\begin{array}{cp{0.75cm}cp{0.55cm}c}
               &&\Rnode{Eb1}{E_{b_1}}   &&                      \\ [0.6cm]
               &&\Rnode{Eb2}{E_{b_2}}   &&                      \\ [0.2cm]
\Rnode{Jnctn}{}&&  \vdots               &&\Rnode{RightJnctn}{}  \\ [0.1cm]							
               &&\Rnode{Ebn}{E_{b_n}}   &&                      \\ [0cm]
							 &&                       &&\mbox{ }\Rnode{Ed}{E_d}       \\ [0.5cm]
               &&\Rnode{Ec}{{E_c}}      &&                      \\
\end{array}
$
\nchmarr[-20][-45]{Eb1}{Ebn}{Jnctn}{Ec}
\nbput[npos=0.2]{$f_E$}
\ncarc[arcangle=-20]{Eb2}{Jnctn}
\nchmarr[20][15]{Eb1}{Ebn}{RightJnctn}{Ed}
\naput[npos=-0.2]{$ inv_{E_{\langle q_1,...q_n \rangle}}   $}
\ncarc[arcangle=20]{Eb2}{RightJnctn}
\ncarc[arcangle=15]{->}{Ed}{Ec}
\naput[npos=0.4]{$E_{\langle z_1,...z_n \rangle}$}
\end{center}
} 
\noindent or
\item{
the family $f_E$ is reducible to an irreducible family $g_E$ and the family $g_E$ is represented in the model. 
}
\end{enumerate}
\end{definition}



\begin{remark}
For any entity model $\genericmodel$ and for any type $b$ of $\genericmodel$ the family of identity functions on 
entities of type $b$ :
$$
id_{E_b} : E_b \rightarrow E_b
$$
is represented because we can choose both $q: b \rightarrow b$ and and
$z: b \rightarrow b$ to be the empty path $\langle \rangle$; then we have:
\begin{align*}
inv_{E_{\langle q_1,...q_n\rangle}}\circ E_{\langle z_1,...z_l \rangle} & = inv_{E_{\langle \rangle}} \circ E_{\langle \rangle} \\
                                                                        & = id_{E_b}^{-1} \circ id_{E_b} \\
                                                                        & = id_{E_b} 
\end{align*}
as required.
\end{remark}
\begin{remark}
For any entity model $\genericmodel$, for any $n \geq 1$, for any tuple of types $b_1,...b_n$ and for any $i$, $1 \leq i \leq n$, if in any instance
$E$ of $\genericmodel$, ${p_i}_{_E}$ is the i'th projection function:
$$
{p_i}_{_E}: E_{b_1} \times ... \times E_{b_n} \rightarrow E_{b_i}
$$
then the family of functions ${p_i}_{_E}$ are represented in model $\genericmodel$. This is because this family of functions is reducible to the family of identify functions on $E_{b_i}$ and this family is represented as previously remarked.
\end{remark}



\begin{definition}
\noindent An ER model $\genericmodel$ is \term{well-formulated} 
 iff 
\begin{enumerate} [(i)]
\item{
for each entity type $a$, there is no proper subset $I$ of the set of identifying edges $\idEdges{a}$ that  is jointly monomorphic
}
\item{ 

\marginpar{\footnotesize{In logical model no such $f_1,...f_n$ distinct from $k_1,...k_n$. Could redefine logical model so that fks are allowed. But how many - relational or hierarchical? ... physically necessary are logically redundant...}}

for all entity types $a$ and for all entity types $b$ with identifying outgoing edges
$k_{i, 1 \leq i \leq n}$ where for each $i$, $k_i: b \rightarrow b_i$,
for each  family of edges $f_i: a \rightarrow b_i$  such that  
$\langle f_1,...f_n \rangle$ references $b$ with respect to $\langle k_1,...k_n \rangle$,
the path $\langle f_1,...f_n,I_b \rangle$ is explicitly represented. Note that from this condition it follows
that for all entity types $a$ and for all entity types $b$,  for all  identifying tuples 
$\langle q_1,...q_n \rangle$ 
with respect to $b$, where for each $i$, $q_i: b \rightarrow b_i$,
for each  family of edges $f_i: a \rightarrow b_i$  such that  
$\langle f_1,...f_n \rangle$ references $b$ with respect to $\langle q_1,...q_n \rangle$,
the path $\langle f_1,...f_n,I_{\langle q_1,...q_n \rangle} \rangle$\marginpar{\footnotesize $I_{\langle q_1,...q_n \rangle}$ isn't defined!} is explicitly represented.

\begin{center}
$
\begin{array}{cp{0.5cm}c c c }
   \Rnode{a}{a}     & &                 & \Rnode{b}{b} &          \\[1.5cm]     
	                  & & \Rnode{b1}{b_1} & \ \hdots   \ \     & \Rnode{bn}{b_n}  
\end{array}
$
\ncarr{a}{b1} 
\blabel{f_1}[0.25]
\ncarr{a}{bn}
\alabel{f_n}[0.25]
\ncarr{b}{b1}
\blabel{k_1}[0.25][1]
\ncput[npos=0.1, nrot=:U]{\psline(0,-0.1)(0,0.1)}
\ncarr{b}{bn}
\alabel{k_n}[0.25]
\ncput[npos=0.1, nrot=:U]{\psline(0,-0.1)(0,0.1)}
\end{center}
}

\item [(ii')]{  \marginpar{\footnotesize (ii') spells out condition(ii)}
for all entity types $a$ and for all entity types $b$ with identifying outgoing edges
$k_{i, 1 \leq i \leq n}$ where for each $i$, $k_i: b \rightarrow b_i$,
for each  family of edges $f_i: a \rightarrow b_i$
if in every instance $E$ of $\genericmodel$ the function $\tuple{E_{f_1},...E_{f_n}}:E_a \morph E_{b_1} \cross ... \cross E_{b_n}$
factors through the function $\tuple{E_{b_1},...E_{b_n}}:E_b \morph E_{b_1} \cross ... \cross E_{b_n}$ then there exists a simple path
$p:a \morph b$ in $M$ such that in each instance $E$, for each $i$, $1 \leq i \leq n$, $E_{f_i} = E_{f} \circ E_{k_i}$. 
}

\item [(ii'')]{ 
\marginpar{ \footnotesize(ii'') the category with products variant of condition (ii). To get (ii') from (ii'') substitute
$b1 \times ... \times b_n$ for $x$, $\tuple{f_1,...f_n}$ for $f$, $\tuple{b_1,...b_n}$ for $b$.}
for all diagrams 
\begin{center}
$
\begin{array}{cp{0.75cm}c}
   \Rnode{a}{a}     & & \Rnode{x}{x}  \\[1.2cm]     
	                  & & \Rnode{b}{b}  
\end{array}
$
\ncarr{a}{x} 
\alabel{f}[0.33]
\ncarr{b}{x}
\blabel{m}[0.3]
\ncput[npos=0.1, nrot=:U]{\psline(0,-0.1)(0,0.1)}
\end{center}

in \cat{C} if in all instances $I \in M$, 
$I(f)$ factors through $I(m)$ then $f$ factors through $m$ i.e. there is an $f_0: a \morph b$ in \cat{C} such that 
$f_0 \circ m =f$. Note that because $m$ is monic $f_0$ is the unique such morphism and if in some instance $I$
$e: I(a) \morph I(b)$ is a function such that $e \circ I(m) = I(f)$ then $I(f_0)=e$. 
}
\item[(iii)]{
if for some $n \geq 1$, $a$, $b_{i, 1 \leq i \leq n}$,  and $c$ are entity types and if  $x_{i, 1 \leq i \leq n}$, and $y$ are simple paths such
that for each $i$, $x_i : a \rightarrow b_i$, and such that $y: a \rightarrow c$ 
as shown here:
\setlength{\arraycolsep}{.2cm}
\begin{center}
$
\begin{array}{cp{2cm}cc}
             & &         & \Rnode{b1}{b_1} \\ [0.5cm]
						 & &         & \Rnode{b2}{b_2} \\ [0.6cm]
						 & & \vdots  &                 \\ [0.2cm]
\Rnode{a}{a} & &         & \Rnode{bn}{b_n} \\ [1.0cm]
             & &         & \Rnode{c}{c}   \\
\end{array}
$
\simplepatha{$x_1$}{a}{b1}
\simplepatha{$x_2$}{a}{b2}
\simplepatha{$x_n$}{a}{bn}
\simplepathb{$y$}{a}{c}
\end{center}
\noindent  if in each instance $E$ there exists a unique partial \marginpar{\footnotesize why unique?}
function $f_E: E_{b_1} \times E_{b_n} \rightarrow E_c$ \marginpar{\footnotesize partial function}
\noindent such that 
domain of $f_E \subseteq img(E_{\langle x_1,... x_n \rangle})$ 
and  
$E_{\langle x_1,..x_n \rangle} \circ f_E = E_y$ 
\begin{center}
$
\begin{array}{cp{2cm}ccp{0.5cm}cc}
						    & &         & \Rnode{Eb1}{E_{b_1}}& &                            &        \\ [0.6cm]
						    & &         & \Rnode{Eb2}{E_{b_2}}& &                            &        \\ [0.6cm]
						    & &\vdots  &                      & &                            &        \\ [0.2cm]												
\Rnode{Ea}{E_a} & &         & \Rnode{Ebn}{E_{b_n}}& & \Rnode{Jnctn}{}&  \\ [1.0cm]
						    & &         & \Rnode{Ec}{{E_c}}   & &                            &        \\
\end{array}
$
\simplepatha{$E_{x_1}$}{Ea}{Eb1}
\simplepatha{$E_{x_2}$}{Ea}{Eb2}
\simplepatha{$E_{x_n}$}{Ea}{Ebn}
\simplepathb{$E_y$}{Ea}{Ec}
\nchmarr[15][45]{Eb1}{Ebn}{Jnctn}{Ec}
\naput[npos=-0.1]{$f_E$}
\ncarc[arcangle=15]{Eb2}{Jnctn}
\end{center}

and the family of functions $f_E$ is irreducible 
then
either in every instance $E$, $E_{\langle x_1,..x_n \rangle}$ is injective or else
the family of functions $f_E$ are represented in the model
\marginpar{\footnotesize More general form of representation needed. See sketchmonics?}
by a path $\tuple{\tuple{q_1,...q_n,I_d},z}$ for some 
 entity type $d$, and some identifying tuple $q_1,...q_n$ of simple paths with respect to $d$,
and some path  $z:d \morph c$ such that  $\langle x_1,..x_n \rangle$ references $d$ with respect to
$q_1,...q_n$ 
\setlength{\arraycolsep}{.2cm}
\begin{center}
\marginpar{\footnotesize Achieve more general form via definition of transitive and, in this way, intransitive?}
$
\begin{array}{cp{2cm}cc p{1.3cm} c}
             & &         & \Rnode{b1}{b_1} & & \\ [0.5cm]
						 & &         & \Rnode{b2}{b_2} & & \\ [0.6cm]
						 & & \vdots  &                 & & \Rnode{d}{d}\\ [0.2cm]
\Rnode{a}{a} & &         & \Rnode{bn}{b_n} & & \\ [1.0cm]
             & &         & \Rnode{c}{c}    & & \\
\end{array}
$
\simplepatha{$x_1$}{a}{b1}
\simplepatha{$x_2$}{a}{b2}
\simplepatha{$x_n$}{a}{bn}
\simplepathb{$y$}{a}{c}
\ncarr{d}{b1}
\blabel{q_1}
\ncput[npos=0.1, nrot=:U]{\psline(0,-0.1)(0,0.1)}
\ncarr{d}{bn}
\alabel{q_n}
\ncput[npos=0.1, nrot=:U]{\psline(0,-0.1)(0,0.1)}
\ncarr{d}{c}
\alabel{z}
\end{center}
and from which it follows, by the way, (from note in clause (ii)) that there is a simple path $p:a \rightarrow d$ such
that in all instances $E$,
$$
E_{\langle x_1,..x_n \rangle} \circ inv_{E_{\langle q_1,...q_n \rangle}} = E_p
$$
}
\end{enumerate}

\end{definition}



\section{Definitions Of Logical and Physical Entity Models}
\subsection{Preliminaries}
\begin{definition}
\noindent An \term{equi-join condition} between two entity types $a$ and $b$ is defined to be a sequence of pairs of attributes of 
 $a$ respectively $b$ i.e it is for some $n$, $n \geq 1$ a sequence of $n$ pairings of attributes of $a$, respectively, $b$, i.e. a function $\sigma: N_n \rightarrow \attrs{a} \times \attrs{b}$. \\
\end{definition}

\noindent If $\sigma$ is a equi-join condition between two entity types $a$ and $b$ then we will denote the i'th pairing of attributes as $\sigma_{i,1},\sigma_{i,2}$. 
Thus we have that  $\sigma_{i,1} \in \attrs{a}$ and $\sigma_{i,2} \in \attrs{b}$. \\

\noindent If $\sigma$ is a equi-join condition within a schema $s$\marginpar{\footnotesize model $M$?} and if $E$ is an instance of $s$ then denote by $E_\sigma$
the many-valued function from $E_a$ to $E_b$
defined by $\sigma(e) = \{ e' \in E_b : \forall i \in N_n, \sigma_{i,1}(e)=\sigma_{i,2}(e') \}$. \\

\begin{definition}
An equi-join condition  $\sigma$ between two entity types $a$ and $b$ is defined to be an 
\term{inclusion dependency}
iff the set $E_\sigma(e)$ is non-empty, for all instances E of s\marginpar{\footnotesize wherefore $s$?} and for all $e \in E_a$. \\
\end{definition}

\noindent
By the \term{domain} of a join condition $\sigma$ in an instance $E$ we shall mean the  set $\{ e \in E_a \| \forall i, 1 \leq i \leq n, \sigma_{i,1}(e) \mbox{is defined} \}$.\marginpar{\tiny typesetting error has been corrected} \\


\begin{definition}
An inclusion dependency $\sigma$ between two entity types $a$ and $b$ is 
\term{referential}\footnote{Also called a referential constraint or a foreign key constraint. Oracle Database Concepts Documentation: \textit{If any column of a composite foreign key is null, then the non-null portions of the key do not have to match any corresponding portion of a parent key.}  } 
iff the set $E_\sigma(e)$ is a singleton set, for all instances E and for all $e$ in the domain of  $\sigma$ . 
\end{definition}
	
\subsection{Definition of Logical ER Model}

\begin{definition}
A well-formulated ER model is \term{purely-logical}  iff it 
also satisfies:
(i) 
\marginpar{\footnotesize(i) no redundancy}
there are no edges $r$ such that there is 
a simple path $p$ which does not include $r$ in its definition and such that $r \simeq p$  
and (ii)
\marginpar{\footnotesize(ii) no foreign keys}
 there are no non-trivial referential inclusion dependencies. \\
\end{definition}

\noindent
We say that an ER model is a \term{logical ER model} iff it is purely logical.

\subsection{Definition of Physical ER Model}
\begin{definition}
\noindent 
A \term{physical ER model} is a well formulated ER model
\marginpar{\footnotesize could add some of no redundancy condition (i) of defn. of logical here}
\marginpar{\footnotesize alternatively could move some of no redundancy condition (i) of defn. of logical back to well-formulated}
that also satisfies:
 (i) all identifying edges are attributes and 
(ii) for each relationship $r$ there is navigational path $p$ containing only attributes such that $r \simeq p$. 
\end{definition}
\marginpar{\footnotesize Consider move no `redundancy except for foreign keys' back into definition of well formulated.}

\section{First Cut Chen Transformation}
\noindent The transformation described by Chen provides a  first cut transformation from a logical model to a physical model recursively.

\noindent If $\genericmodel$ is a model then in the Chen transformed model $\chengenericmodel$ 
the attributes of an entity type $a$ are the attributes of $a$ in the model $\genericmodel$,  plus additional 'physical' attributes implementing outgoing relationships :
\noindent
$$
\chenAttrs{a} = \attrs{a} \cup \chenFKattrs{a}
$$
\noindent
where :
$$
\chenFKattrs{a} = \sum_{r \in \rels{a}}{\chenIdAttrs{dst(r)}}
$$

\noindent In this definition, $\chenIdAttrs{dst(r)}$ denotes the subset of identifying attributes of the destination of
a relationship $r$ in the transformed model. These are the identifying attributes of the original model plus the 'physical' attributes which implement \textit{identifying} relationships.

$$
\chenIdAttrs{a} = \idAttrs{a}  \cup \chenFKidAttrs{a}
$$
where:
$$
\chenFKidAttrs{a} = \sum_{r \in \idRels{a}}{\chenIdAttrs{dst(r)}}
$$


\noindent What these recursive definitions express is that the attributes of the physical model are those of the logical model plus simple paths $\langle r_0,r_1,...r_n,a \rangle$ where $n \geq 0$,  where for $i \geq 1$,  $r_i$ is itself an identifying relationship and  where
$a$ is an identifying attribute. Such an attribute $\langle r_0,...r_n, a \rangle$  is an identifying iff  $r_0$ is identifying.\\


\noindent The definition of $\chenFKattrs{a}$ can be reformulated in this way:
$$
\chenFKattrs{a}=\sum_{n \geq 0} \, \sum_{r_0 \in \rels{a}} \; \sum_{\; r_1 \in \idRels{dst(r_0)}}...\sum_{\;r_n \in \idRels{dst(r_{n-1})}}\!\!\!\!\idAttrs{dst(r_n)}
$$
and the definition of the subset $\chenFKidAttrs{a}$ can similarly be reformulated:
$$
\chenFKidAttrs{a} = \sum_{n \geq 0} \, \sum_{r_0 \in \idRels{a}} \; \sum_{\; r_1 \in \idRels{dst(r_0)}}...\sum_{\;r_n \in \idRels{dst(r_{n-1})}}\!\!\!\!\idAttrs{dst(r_n)}
$$

\noindent These reformulated definitions are the starting point for the definitions that follow.

\section{Chi Transform - a Revised Chen Transformation}

\newcommand{\pathclasses}[1]{\chenFKattrs{#1}\hspace{-1pt}/\hspace{-2pt}\simeq}

\noindent To correct the Chen transformation we take note of equivalent paths so as not to introduce redundant attributes. \\

\noindent
Say that a path $\langle r_0,r_1,...r_n \rangle \in \chenFKattrs{a}$ \textit{is subsumed by} a simple path 
$\langle s_0,s_1,...s_m \rangle$ iff $m \geq 1$ and either:
\begin{enumerate} [(i)]

\item $\langle r_0,r_1,...r_n \rangle \simeq  \langle s_0,s_1,...s_m \rangle$ and for some j, $j > 1$,
$s_j$ is not identifying. \\

 \hspace{1cm} or:
\item $\langle r_0,r_1,...r_n \rangle <  \langle s_0,s_1,...s_m \rangle$ and $r_0 \neq s_0$.
\end{enumerate}

\noindent
We define $\chiOne{a}$ to be the subset of $\chenFKattrs{a}$ consisting of those paths for which there are no paths that subsume them. \\
 

\noindent We define the Chi transformed model $\chigenericmodel$ by:
$$
\chiAttrs{a} = \attrs{a} \cup \chenFKclasses{a}
$$
\noindent where $\chenFKclasses{a}$ is the set of equivalence classes of paths in $\chiOne{a}$
with respect to the $\simeq$ equivalence relation. \\ 

\noindent and by:
$$
\chiIdAttrs{a} = \attrs{a} \cup \chenFKidClasses{a}
$$

\noindent where\footnote{In fact this definition needs modifying to deal with cases when an $r$ sequence is subsumed by two distinct
$s$ sequences - otherwise too many identifying attribues are generated. %11 Aug 2016 example with s0,s1, s0',s1' page 2.
}:
\begin{multline}
\chenFKidClasses{a} = 
\{ C \in \chenFKclasses{a} | \mbox{ there exists }
\langle s_0, s_1,...s_m \rangle \in C \mbox{ such that either }
 s_0 \mbox{ is identifying or } \\
 \mbox { there exists } \langle r_0, r_1,...r_n \rangle \in \chenFKidAttrs{a} \mbox{ and a simple path }  \langle s'_1,...s'_{m'} \rangle \mbox{ such that } \\
r_0
\mbox{ is identifying and }    
\langle r_0,r_1,...r_n \rangle \mbox{ is subsumed by } \langle s_0, s'_1,...s'_{m} \rangle  \}
\end{multline}
\section{Boyce-Codd Normal Form}
\noindent One measure of the goodness of a physical model is whether it satisfies the well-formedness condition know as Boyce Codd Normal Form.
Written in the terminology we are using here it can be expressed as follows: a physical ER model is in Boyce Codd Normal Form (BCNF) 
\marginpar{\footnotesize  Need to come to terms with the partiality -  isn't quite right in this area. Would be good if could say if y defined then y equals but I dont think that OK either.} iff
for all entity types $a$, for all attributes $x_1,...x_n$ and $y$, $n \geq 1$, if in all instances $E$, there exists a unique n-ary partial function
$f$ such that $E_{<x_1,...x_n>} \circ f = E_y$ then either $y$ is $x_i$ for some $i$ or else in all instances
$E$, $E_{<x_1,...x_n>}$ is injective.  \\

\noindent The next lemma simplifies the requirement for showing BCNF to consideration of irreducible families of functions:
\begin{lemma}
A model $\genericmodel$ is in BCNF iff
for all entity types $a$, for all attributes $x_1,...x_n$ and $y$, $n \geq 1$, 
in all instances $E$, there exists a (unique?) n-ary partial function
$f$ such that $E_{<x_1,...x_n>} \circ f = E_y$ and if the family of functions $f_E$ is irreducible then either 
$n=1$, $x_1=y$ and $E_f=id_{E_y}$
 or else in all instances
$E$, $E_{<x_1,...x_n>}$ is injective. 
\marginpar{\footnotesize $f: Img(E_{<x_1,...x_n>} \morph v$ such that $E_g \leq E_{<x_1,...x_n>} \circ f$}
\marginpar{\footnotesize $E_g$ missing I-mark?????}
\end{lemma}
\begin{proof}
Suppose $\genericmodel$ is an ER model and that $a$ is an entity type of $\genericmodel$ and that $x_1,...x_n$ and $y$ 
are attributes of $a$ and suppose that in all instances $E$ of $\genericmodel$ there is a unique function $f_E : \Vtype \rightarrow \Vtype$
such that
$$
E_{\langle x_1,...x_n \rangle} \circ f_E = E_y
$$
Suppose that $f_E$ is reducible to $g_E$ and that  $g_E$ is irreducible. We have therefore that, for some $J$,
$$
f_E=P_J \circ g_E
$$ 
and therefore that
$$
E_{\langle x_1,...x_n \rangle} \circ P_J \circ g_E = E_y
$$

\noindent and because 
$$
E_{\langle x_1,...x_n \rangle} \circ E_{proj_J} = E_{\langle x_{i_1},...x_{i_j} \rangle}
$$
it follows that
$$
E_{\langle x_{i_1},...x_{i_j} \rangle} \circ g_E = E_y.
$$
Since $g_E$ is irreducible it follows from the initial assumption that either $j=1$ and $x_{i_1}=y$ and $y$ is one of the 
$x_1,...x_n$ as required or else $E_{\langle x_{i_1},...x_{i_j} \rangle}$ is injective from which it follows that 
$E_{\langle x_1,...x_n \rangle}$ is injective, as required.
\end{proof}

\noindent We aim to show:\\
\noindent \textbf{Theorem}\\
\noindent If an ER model $\genericmodel$ is well-formulated  then the 
transformed model $\logtophys(\genericmodel)$  is in Boyce-Codd Normal Form.  \\

\newcommand{\phys}[1]{\overline{#1}}
\newcommand{\genericphysical}{\logtophys(\genericmodel)}

\noindent \textbf{Proof}\\
\noindent Suppose that $\phys{x}_1,...\phys{x}_n,\phys{y}$ are attributes of the entity type $a$ of model $\genericphysical$ suppose 
that in all instances $E$ of $\genericphysical$ there exists a unique n-ary partial function
$E_f$ such that 
$E_{<\phys{x}_1,...\phys{x}_n>} \circ E_f = E_{\phys{y}}$ 
we need to show that 
either $\phys{y}$ is $\phys{x}_i$ for some $i$ or else in all instances
$E$ of $\genericphysical$, $E_{<\phys{x}_1,...\phys{x}_n>}$ is injective. \\


\noindent From the definition of $\logtophys$ it follows that 
for each $\phys{x}_i$  there is a $m_i, m_i \geq 1$ and 
a simple path $\langle x_{i,1},...x_{i,m_i} \rangle$ in $\genericmodel$
where $x_{i,j}$ is identifying, for $j > 1$ and $dest(x_{i,m_i})=v$ 
such that either, $m_i = 1$ and $\phys{x}_i = x_{i,1}$ or $m_i > 1$ 
and $\phys{x}_i= \left[ \langle x_{i,1},...x_{i,m_i}\rangle \right]$. 
It follows likewise that for some $m \geq 1$, there is a simple path
$\langle y_1,..y_m \rangle$ in $\genericmodel$ such that either $m=1$ and $\phys{y}=y_m$ or $m >1$ and 
$\phys{y}=\left[\langle y_1,..y_m \rangle\right]$. \\

\noindent In the model $\genericmodel$ therefore, for each $i$, $1 \leq i \leq n$, for some $m_i$, $m_i \geq 1$, we have a 
path of length $m_i$ which we denote $x_i = \langle x_{i,1},...x_{i,m_i} \rangle$  and for some $m$, $m \geq 1$ we have a path 
of length $m$ which we denote 
$y=\langle y_1,..y_m \rangle$ as shown here: 
\setlength{\arraycolsep}{.2cm}
\begin{center}
$
\begin{array}{cp{2cm}cc}
             & &         & \Rnode{b1}{v} \\ [0.5cm]
						 & &         & \Rnode{b2}{v} \\ [0.6cm]
						 & & \vdots  &                 \\ [0.2cm]
\Rnode{a}{a} & &         & \Rnode{bn}{v} \\ [1.0cm]
             & &         & \Rnode{c}{v}   \\
\end{array}
$
\simplepatha{$x_1$}{a}{b1}
\simplepatha{$x_2$}{a}{b2}
\simplepatha{$x_n$}{a}{bn}
\simplepathb{$y$}{a}{c}
\end{center}

\noindent Each instance $E$  of $\genericmodel$ gives rise to an instance $\logtophys(E)$ of $\genericphysical$ and from the
definition of $\logtophys(E)$ it follows that for every instance $E$ of $\genericmodel$ there is a unique 
function $E_f$ such that $E_{<x_1,...x_n>} \circ E_f = E_{y}$, as shown here:
\begin{center}
$
\begin{array}{cp{2cm}ccp{0.5cm}cc}
						    & &         & \Rnode{Eb1}{E_{v}}& &                            &        \\ [0.6cm]
						    & &         & \Rnode{Eb2}{E_{v}}& &                            &        \\ [0.6cm]
						    & &\vdots  &                      & &                            &        \\ [0.2cm]												
\Rnode{Ea}{E_a} & &         & \Rnode{Ebn}{E_{v}}& & \Rnode{Jnctn}{}&  \\ [1.0cm]
						    & &         & \Rnode{Ec}{{E_v}}   & &                            &        \\
\end{array}
$
\simplepatha{$E_{x_1}$}{Ea}{Eb1}
\simplepatha{$E_{x_2}$}{Ea}{Eb2}
\simplepatha{$E_{x_n}$}{Ea}{Ebn}
\simplepathb{$E_y$}{Ea}{Ec}
\nchmarr[15][45]{Eb1}{Ebn}{Jnctn}{Ec}
\naput[npos=-0.1]{$f_E$}
\ncarc[arcangle=15]{Eb2}{Jnctn}
\end{center}

\noindent
From the assumption that the model $\genericmodel$ is well-formulated and from condition (iii) 
of the definition of well-formulated, either 
$E_{\langle x_1,...x_n \rangle}$ is injective in every instance $E$ of $\genericmodel$ in which case 
$\logtophys(E)_{\langle \phys{x}_1,...\phys{x}_n \rangle}$ is injective in every instance $E$ of $\genericmodel$ and the proof is completed or else
the family of function $f_E$ are represented in the model $\genericmodel$. From the definition of a function family being represented it follows that
either (i)  y is $x_i$ for some $i$ 
from which it follows that $\phys{y}$ is $\phys{x}_i$ for some $i$ and the proof is complete or (ii) there
is an entity type $b$ in $\genericmodel$ and an identifying family of simple paths $q_1,...q_n$, 
$q_i: b \rightarrow v$ and a 
path $z: b \rightarrow v$ such that in every instance $E$ of $\genericmodel$:
\newcommand{\ineveryinstance}{\forall E \in inst_\genericmodel ,  \hspace{0.25cm} }
\begin{equation*}
inv_{E_{\langle q_1,...q_n \rangle}} \circ E_{z} = f_E
\end{equation*}
\noindent from which it follows that in every instance $E$ of $\genericmodel$:  
\begin{equation*}
E_{\langle x_1,...x_n \rangle}\circ inv_{E_{\langle q_1,...q_n \rangle}} \circ E_{z}  = E_{\langle x_1,...x_n \rangle} \circ f_E 
\end{equation*}
\noindent and thus, from our initial assumption, that:
\begin{equation}
\label{representationByIdentifyingRelationships}
\ineveryinstance E_{\langle x_1,...x_n \rangle}\circ inv_{E_{\langle q_1,...q_n \rangle}} \circ E_{z} = E_{\langle y_1,..y_m \rangle} 
\end{equation}
\noindent In this case, because $\genericmodel$ is well-formulated and from condition (ii) of the definition of well-formulated it follows that there exists
a path $\langle p_1,...p_k \rangle:a \rightarrow b$, $k \geq 0$, such that:
\begin{equation}
\label{simpleRepresentationOfFirstPart}
\ineveryinstance \langle E_{x_1},...E_{x_n} \rangle \circ inv_{E_{\langle q_1,...q_n \rangle}} = E_{\langle p_1,...p_k \rangle}
\end{equation}
\noindent Either $k=0$ and $\langle q_1,...q_n \rangle = \langle x_1,...x_n \rangle$ in which case $E_{\langle x_1,...x_n \rangle}$ is
injective in every instance $E$ of $\genericmodel$ and thus $\logtophys(E)_{\langle \phys{x}_1,...\phys{x}_n \rangle}$ is
injective in every instance $\logtophys(E)$ of $\genericphysical$ and the proof is complete 
\noindent or else $k \geq 1$ and it follows from (\ref{representationByIdentifyingRelationships}) and (\ref{simpleRepresentationOfFirstPart}) that:
\begin{equation} 
\label{simpleRepresentation}
\ineveryinstance  E_{\langle p_1,...p_k \rangle} \circ E_{\langle z_1,...z_l \rangle} = E_{\langle y_1,..y_m \rangle} 
\end{equation}
\noindent We will show that this leads to a contradiction and so complete the proof. If $m >1$ it follows 
 from  (\ref{simpleRepresentation}) 
that $p_2,...p_k,z_1,...z_l$ subsume $\langle y_1,..y_m \rangle$, 
which implies that $\langle y_1,..y_m \rangle$ is excluded from $\chiOne{a}$ and thus that 
 $\phys{y}=\left[\langle y_1,..y_m \rangle\right]$ is not an attribute of $\genericphysical$ contrary to our 
initial assumption. We must conclude that $m=1$.
In this case we have $y_1$ an attribute of $a$ in $\genericmodel$ and from (\ref{simpleRepresentation})  we have in all instances $E$ of $\genericmodel$:
\begin{equation}
E_{y_1}=E_{\langle p_1,...p_k \rangle} \circ E_{\langle z_1,...z_l \rangle}
\end{equation}
\noindent which is to say in all instances $E$ of $\genericmodel$:
\begin{equation}
E_{y_1}=E_{\langle p_1,...p_k ,z_1,...z_l \rangle}
\end{equation}
\noindent
We have shown, therefore, that $y_1$ is an outgoing edge of $a$ in $\genericmodel$ which is equivalent to a simple path of $\genericmodel$ of length $\geq 2$ which contradicts  the 
 initial assumption that the model $\genericmodel$ is purely logical and so completes the proof.

\end{document}
