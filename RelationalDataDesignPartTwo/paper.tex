%\documentclass[prodmode,acmtods]{acmsmall}
\documentclass[10pt,a4paper]{article}
\input{../SharedMacros/ccategories.macros}
\input{../SharedMacros/ermacros}
\input{../SharedMacros/erdiagram}
\input{../SharedMacros/theorems.macros}
\usepackage{mathptmx}  % This changes font to roman
\usepackage{anyfontsize}
\usepackage{mathtools}  % why have we got this?
\usepackage{alltt}    
\usepackage{mnsymbol} %used for rightpitchfork
\usepackage{cmll}
\usepackage{ulem}
\renewcommand{\ttdefault}{txtt}
\usepackage[left=1.5cm, right=4cm, marginparwidth=3cm, top=2cm, bottom=1.5cm]{geometry}
\usepackage{framed}
\usepackage[font=small]{caption}
\setlength{\captionmargin}{2cm}
\newcommand{\commentary}[1]{\marginpar{\footnotesize #1}}

\renewcommand{\erpictureFolder}[0]{../SharedPictures}

\newenvironment{categoricalaside}
{\begin{framed}
\textbf{Categorical Aside}
}
{
\end{framed}
}

%from berkley
\newcommand{\langl}{\begin{picture}(4.5,7)
\put(1.1,2.5){\rotatebox{60}{\line(1,0){5.5}}}
\put(1.1,2.5){\rotatebox{300}{\line(1,0){5.5}}}
\end{picture}}
\newcommand{\rangl}{\begin{picture}(4.5,7)
\put(.9,2.5){\rotatebox{120}{\line(1,0){5.5}}}
\put(.9,2.5){\rotatebox{240}{\line(1,0){5.5}}}
\end{picture}}
\newcommand{\lang}{\begin{picture}(5,7)\put(1.1,2.5){\rotatebox{45}{\line(1,0){6.0}}}\put(1.1,2.5){\rotatebox{315}{\line(1,0){6.0}}}\end{picture}}
\newcommand{\rang}{\begin{picture}(5,7)\put(.1,2.5){\rotatebox{135}{\line(1,0){6.0}}}\put(.1,2.5){\rotatebox{225}{\line(1,0){6.0}}}\end{picture}}
%Try sharper tuple brackets -- except gives errors nested in captions so comment out
%\renewcommand{\tuple}[1]{\lang #1 \rang}

\newcommand{\setsuchthat}[2]{\left\{#1 \ \middle|\ #2\right\}}
\newcommand{\set}[1]{\left\{#1\right\}} 

\newcommand{\genericmodel}{\mathcal{M}}
\renewcommand{\genericmodel}{{m}}
\newcommand{\chiZero}{\mathcal{X}_0}
\newcommand{\chiZeroM}{\chiZero(\genericmodel)}
%\newcommand{\chiOne}{\mathcal{X}_1}
%\newcommand{\chiOneM}{\chiOne(\genericmodel)}
\newcommand{\chiM}{\mathcal{X}(\genericmodel)}
\newcommand{\veee}{v}
\newcommand{\Veee}{V}
\newcommand{\et}[1][\genericmodel]{et_{#1}}
\newcommand{\edge}[3][\genericmodel]{Edge_{#1}(#2,#3)}
\newcommand{\iedge}[3][\genericmodel]{IEdge_{#1}(#2,#3)}
\newcommand{\path}[3][\genericmodel]{Path_{#1}(#2,#3)}
\newcommand{\ipath}[3][\genericmodel]{IPath_{#1}(#2,#3)}
\newcommand{\attr}[2] [\genericmodel]{attr_{#1}(#2)}
\newcommand{\iattr}[2] [\genericmodel]{IAttr_{#1}(#2)}
\newcommand{\rel}[3][\genericmodel]{rel_{#1}(#2,#3)}
\newcommand{\irel}[3][\genericmodel]{IRel_{#1}(#2,#3)}
\newcommand{\iedges}[2] [\genericmodel]{i_{#1}(#2)}
\newcommand{\pk}[2] [\genericmodel]{pk_{#1}(#2)}
\newcommand{\fk}[2] [\genericmodel]{fk_{#1}(#2)}
\newcommand{\fkp}[2] [\genericmodel]{fk'_{#1}(#2)}
\newcommand{\fkpp}[2] [\genericmodel]{fk''_{#1}(#2)}

%functional dependencies
\newcommand{\sfd}[2]{\ensuremath{\set{#1} \morph #2}}  %singleton
\newcommand{\fd}[2]{\ensuremath{\sfd{#1}{\set{#2}}}}

\newcommand{\simplepath}[2]{
\ncline[linestyle=dotted,linewidth=0.1pt]{#1}{#2}
\ncput[npos=0.05]{\pnode{dot#21}}
\ncput[npos=0.27]{\dotnode[dotsize=1pt]{dot#22}}
\ncput[npos=0.50]{\dotnode[dotsize=1pt]{dot#23}}
\ncput[npos=0.80]{\dotnode[dotsize=1pt]{dot#24}}
\ncput[npos=0.975]{\pnode{dot#25}}
\ncline[nodesep=3pt]{->}{dot#21}{dot#22}
\ncline[nodesep=3pt]{->}{dot#22}{dot#23}
\ncline[nodesep=3pt]{->}{dot#24}{dot#25}
\ncline[linestyle=dotted,nodesep=10pt]{dot#23}{dot#24}
}

\newcommand{\simplepatha}[3]{
\simplepath{#2}{#3}
\naput[labelsep=1pt]{#1}
}

\newcommand{\simplepathb}[3]{
\simplepath{#2}{#3}
\nbput[labelsep=1pt]{#1}
}
\newcommand{\term}[1]{\textit{{#1}}}
\newcommand{\logtophys}{\mathcal{X}}
\newcommand{\chen}{\mathcal{X}_0}
\newcommand{\chengenericmodel}{\chen(\genericmodel)}
\newcommand{\chigenericmodel}{\logtophys(\genericmodel)}
\newcommand{\phys}[1]{\overline{#1}}
\newcommand{\genericphysical}{\logtophys(\genericmodel)}

\newcommand{\inc}{\subseteq}
\newcommand{\incd}[4]{#1\left[#2\right]\inc#3\left[#4\right]}

\newcommand{\ntuple}[1]{\tuple{#1_1,...#1_n}}
\newcommand{\mtuple}[1]{\tuple{#1_1,...#1_n}}

\newcommand {\bntuple}{\ensuremath{\ntuple{b}}}
\newcommand {\fntuple}{\ensuremath{\ntuple{f}}}
\newcommand {\pntuple}{\ensuremath{\ntuple{p}}}
\newcommand {\qntuple}{\ensuremath{\ntuple{q}}}
\newcommand {\xntuple}{\ensuremath{\ntuple{x}}}
\newcommand{\foreachi}[1][n]{for each $i$, $1 \leq i \leq #1$}
\newcommand{\foreachj}[1][m]{for each $j$, $1 \leq j \leq #1$}
\newcommand{\foreachk}[1][l]{for each $k$, $1 \leq k \leq #1$}


\begin{document}
\title{Documenting commutative diagrams of relationships to eliminate sources of redundancy in relational data design - Part Two - Logical to Physical Mathematically}
% abstract here for ams

\author{John Cartmell}

\maketitle
\begin{center}
DRAFT \commentary{ Original Dated 2016 }
      \commentary{ Review started 21 Feb 2019. }
      \commentary{ Addition of variant definitions, notes and  corrections 25/29 April 2019.}
			\commentary{ Major change to terminology to support fix to definition of well-                               formulated including specification of intransitive functional 
			                         dependencies and addition of many examples. 1-10 May 2019.}
			\commentary{ After changes of 20th May 2019 rolled back and further consolidation of definitions. 10 June 2019}
			\commentary{ Continued restructure. Breakout of lemmas from main proof. 19 June 2019}
\end{center}

\section{Introduction}

\noindent 


We can make use of the distinction made in philosophy between 
\textit{particulars} and \textit{universals} and of the fact that types of things and relationships between these are generally considered to be universals, and set out with the viewpoint that
particulars are communicated\footnote{Note that we consider data storage to be a special case of data communication} as data by some systematic use of universals and universals alone and that data specification is the act of defining such a system. The style of data specification system that we study here involves description of types of particulars in terms of their relationships with other types,
of which there are two kinds,  those, such as represent numbers, character strings, booleans and so on, all of whose instances are \textit{universals} and the definienda  -- those types all of whose instances are \textit{particulars}. 

In the presentation by Chen of the
 entity relationship model as a unified model of data the term relationship is used 
to mean n-ary relationship, for some $n$. Subsequent authors retained use of the terms entity and relationship
but moved away from the Chen notation and terminology and eliminated n-ary relationaships from the modelling
in favour of binary relationships that are functional, inclusive of partial functional,  in character.
In this style, what is modelled  for  types of entity $x$ and $y$, are  relationships $R: x \morph y$ such that for all instances $e_x$ of $x$
there exists at most one $e_y$ of type $y$ such that $x R y$. It is reasonable to describe this   as the functional style of entity relationship modelling to distinguish it from the Chen style and
and some authors have presented  systems of such types and relationships as the functional model of data and emphasised navigation through data as functional composition. What we are calling the functional style of ER modelling is exemplified by the
book of Barker, and a limited version of a functional style ER model has been formalised in the language of category theory by Johnstone et al. 

Types all of whose instances are universals  are said to be \textit{attribute types} in entity relational 
modelling, though confusingly called \textit{attributes} by Johnstone et al. and earlier
in Chen were called \textit{value sets}; they are said to be \textit{domains} in relational data modelling theory. 

Types of particulars are said to be 
types of entities or \textit{entity types} in modern entity relational modelling\footnote{In  his paper  introducing the entity-relationship model Chen explains that his model adopts the view that the real world consists of entities and relationships. He also introduces the  terms \textit{entity set} and \textit{relationship set} for the types of respective entity and relationship particulars. Later authors kept the terms entity and relationship, and the philosophy, but changed the way that they were used. In this paper we use the modern terminology.} or sometimes, confusingly, just \textit{entities}  and 
are modelled as \textit{relational tables} in relational data modelling. For the purposes of the theory presented in this paper there is no loss if we assume a single set $\Veee$ of universals.  We will represent data specifications as directed graphs with 
some additional information; the nodes of the graph being types, and having a distinguished node $\veee$ representing the type of universals; from a mathematical point of view it is impossible to progress the theory too far without forming an opinion that a data specification is a presentation of a category with some additional structure or, meta-mathematically, that it is an axiomatisation of a theory of some kind. 

\begin{figure} [h]  % chen fragment SANS bars
\begin{center}
\begin{tabular}{c c}
\barsfalse % supresses \idcomp macro
\input{chenFragment}
& \footnotesize
\begin{tabular}{c p{1.5cm} p{4cm}}
KEY && \\
\hline
p & project & Identified by project number attribute ($pNo$).\\
e & employee & Identified by employee number attribute ($eNo$). \\
w  & project-worker & Identified by combination of relationship $R_0$ to an employee and relationship $R_1$ to a project. Has a percentage of time attribute ($pcnt$) which is percentage of time employee is allocated to work on the project.\\
dep & dependent & Identified by a combination of relationship $S_0$ to an employee and a name attribute ($dN$).\\
\end{tabular} 
\end{tabular}
\end{center}
\caption{A directed graph representing a fragment of Chen's example that illustrates analysis of information for a manufacturing firm. Other attributes such as project name, employee date of birth (dob) and so on not shown.}
\label{chenfragmentSANSbars}
\end{figure}

All styles of entity relationship modelling, and, for that matter, relational modelling too, are 
predicated on the assumption that the particulars that we describe in data 
correspond uniquely to real world entities and that the data 
alone is sufficient to establish a 1-1 correspondence. 
This requires in turn that the logical principle of identity of 
indiscernibles holds of the real world entities. In fact we assume a bit more 
that each type of entity has identifying features that distinguish it from  
others of the type. 
In relational data modelling this set of identifying features as a set of columns of the table and is called the primary key.  

We require that 
for a directed graph to be considered an ER schema each entity type has a set of identifying features
 specified. 
An identifying set of features  $pk_1,...pk_n$ for an entity type $x$ specifies a jointly injective set of functions(the set of functions $f_1,...f_n$ are said to be jointly injective iff the function:
$$
\tuple{f_1,f2,,,,f_n}: x \morph \veee \times \veee ... \times \veee
$$
is injective).

by this means every entity is defined to have a primary key and two entities are necessarily identical if they have the primary entity (so implementing the identity of indiscernibles). Each element of a primary key for entity type $x$ must be specified as a path through the directed graph from node $x$ to the node $\veee$ representing the type of universals.  In the Chen fragment (figure \ref{chenfragmentSANSbars}) the primary keys are specified as follows:
$$
\begin{array}{l l}
p & \set{\tuple{pNo}} \\
e & \set{\tuple{eNo}} \\
w & \set{\tuple{R_1,pNo},\tuple{R_2,eNo}} \\
dep & \set{\tuple{S_0,eNo},dN}
\end{array}
$$

For example, as described by Chen and as shown in text in the key on figure \ref{chenfragmentSANSbars}, each
type of entity can be identified by a specified combination of relationships and attributes. For instance the entity type 
project worker ($w$) in the example in figure \ref{chenfragmentSANSbars} is identified uniquely by a combination of the relationships with a project ($p$) being worked on  and to employee($e$). 
In the book of Barker these relationships can be said to be identifying relationships. 
The entity type dependent, on the other hand, can
be identified uniquely by a combination of its relationship $S$ with a employee ($e$), 
who supports them, and their name, represented by the name attribute $dN$. 
In this case entities of the type can uniquely identified 
by a certain combination of its relationships and attributes.   In the Barker 
style of entity relationship modelling primary keys come about indirectly via specification of these identifying relationships and attributes. In the example shown in figure \ref{chenfragment} indication of the primary keys of each of the four entity types $p$, $e$, $w$ and $dep$ has been given indirectly by marking certain attributes and relationships as \textit{identifying} by way of a bar across the corresponding arrowan adaption of the bar notation used in Barker's book (but in the Barker-Ellis notation is different rougghly speaking the arrow head is swapped for a crowsfoot at the other end of the line). If identifying relationships are used instead
of primary keys then in the simplest cases the implied primary keys of an entity type $x$ are those paths from $x$ to
$\veee$ that consist entirely of identifying attributes and relationships. 
It is almost always the case that in this way the primary keys of an entity type can be determined solely from the identifying relationships
and attributes. So it is that in the Barker book it is the identifying relationships and attributes
which are specified in an entity model and the primary keys are derived from them. This is a good practical approach but as we see later it isn't applicable in 100\% of cases.

\begin{figure} [h]  % chen fragment with bars
\begin{center}
\barstrue
\input{chenFragment}
\end{center}
\caption{The same Chen fragment with bars indicating the identifying relationships and attributes. In this example the primary key for each entity type consists of the set of paths through the graph consisting entirely
of identifying (bar'ed) attributes and relationships and leading from itself to the universal type $\veee$ .}
\label{chenfragment}
\end{figure}

The rule that an entity type has primary keys generated as exactly the paths through the directed graph leading from it
to the type $\veee$ and consisting entirely of identifying relationships and attributes is 
an over simplification\footnote{This is not generally recognised because 
of lack of a proper theory (which we are trying to rectify  here) and because it is obscured by a reliance on
a database normalisation step in database design that hides defects in methodology.}
because in some cases duplicate key elements and redundant key elements will result from this rule as we now see
from two examples.

The first example is illustrated in figure
\ref{datatablegraph}. This example has two equivalent paths because 
each data cell is part of a row which is part of a table and is also part 
of a column that is part of a table and these two tables are one and the same.
Which is to say that paths $\tuple{S_0,S_1}$ and $\tuple{R_0,R_1}$ are equivalent 
paths that is represent identical functions and so to then are the paths
derived from these that might be considered for the primary key namely
$\tuple{S_0,S_1,tN}$ and $\tuple{R_0,R_1,tN}$; clearly just one of these needs
to be included in the primary key. 
\begin{figure} [h] % data table
\begin{center}
\begin{tabular}{c c}
$
\begin{array}{cp{0.75cm}cp{0.75cm}c}
   \Rnode{r}{r}     & & \Rnode{t}{t} & & \Rnode{v}{v} \\[1.2cm]     
	 \Rnode{d}{d}   & & \Rnode{c}{c} & &               
\end{array}
$
\ncarr{r}{t} 
\alabel{S_1}
\idcomp
\ncarr{t}{v} 
\alabel{tN}
\idcomp
\ncarr{c}{v} 
\blabel{cN}
\idcomp
\ncarr{d}{c}
\blabel{R_0}
\idcomp
\ncarr{d}{r}
\alabel{S_0}
\idcomp
\ncarr{c}{t}
\blabel{R_1}
\idcomp
\ncarr[50]{r}{v}
\alabel{rN}
\idcomp

& \footnotesize
\begin{tabular}{c p{1.5cm} p{4cm}}
KEY && \\
\hline
t & table & Having identifying attribute tN the name of the table. \\
c & column & Identified by a combination of column number cN and relationship $R_1$ to the table it is a column of.\\
r & row & Identified by its row number $rN$ and its relationship $S_1$ to the table it is a row of.\\
d & data cell & Identified by relationship $S_0$ to the row it is in and relationship $R_0$ to the row it is in. \\
\end{tabular} 
\end{tabular}
\end{center}
\caption{Example of path equivalence - the path $\tuple{R_0,R_1}$ is equivalent to path $\tuple{S_0,S_1}$}.
\label{datatablegraph}
\end{figure}

A second example is shown in figure \ref{pickexample}. In this example the default rule for inference of primary keys would result in us determining
a primary key for the data cell entity as including a path 
$\tuple{R_0,R_1,wId}$. This would be incorrect for the pick entity 
is determined uniquely from 
$\tuple{S_0,oId}$, $S_0,dSn$ and $\tuple{R_0,cSn}$ alone because 
warehouse us uniquely determined by delivery and so not necessary as a separate 
element of the key. From this example we see that sometimes
the need for a primary key is subsumed. To include the key would be to 
have a badly formulated entity model. We formalise this as a general concept in the next section.
\begin{figure} [h]
\begin{center}
\begin{tabular}{c c}
\begin{tabular}{cp{0.75cm}cp{0.75cm}c}
   \Rnode{d}{d}    & & \Rnode{w}{w}   & & \Rnode{v}{v}\\[1.2cm]     
	 \Rnode{p}{p}  & & \Rnode{c}{c} & &               
\end{tabular}
\ncarr[90]{d}{v}
\alabel{oId}[0.4]
\idcomp
\ncarr[40]{d}{v}
\alabel{dSn}[0.4]
\idcomp
\ncarr{d}{w} 
\alabel{S_1}
\ncarr{w}{v} 
\alabel{wId}
\idcomp
\ncarr{c}{v} 
\blabel{cSn}
\idcomp
\ncarr{p}{c}
\blabel{R_0}
\idcomp
\ncarr{p}{d}
\alabel{S_0}
\idcomp
\ncarr{c}{w}
\blabel{R_1}
\idcomp
& \footnotesize
\begin{tabular}{c p{1.5cm} p{4cm}}
KEY && \\
\hline
d & delivery & Identified by a combination of an order id attribute ($oId$) and a
delivery serial number  attribute ($dSn$). \\
w & warehouse & Identified by a warehouse id attribute ($wId$). \\
c & crate & Identified by a combination of a crate serial number attribute ($cSn$) and a relationship $R_1$ to the warehouse in which it is held.
             Also has an item type attribute (not shown).\\
p & pick & Identified by relationship $S_0$ to the delivery  it is part of and relationship $R_0$ to the crate being picked from. Has a quantity picked attribute (not shown). \\
\end{tabular} 
\end{tabular}
\end{center}
\caption{Pick Example}
\label{pickexample}
\end{figure}


Both these examples show the importance of taking note of equivalent paths through the directed graph. It is the
jumping off point for saying that there is more to an ER model than so far considered -- somehow account must be taken 
of equivalent paths. There are two ways this might be done. A first possible approach ts to include in the idea of an ER model
some notional idea of set of instances that we envisage for it. A second approach would be to add to the structure of a directed
graph an equivalence relation of paths -- mathematicians will recognise this 
as specifying a sketch for a category; this second approach is followed by Johnstone et al. but we shall take the first 
approach which gives us a little more freedom and also, I think, is a little less technical.

\noindent
With this as background we provide a set of general definitions of \term{ER schema}, \term{ER schema instance},
\commentary{ Might there be a use somewhere for the terms \textit{logically redundant} and \textit{physically redundant}?}
and \term{ER model} so that from the definition of \term{ER model} we capture the notion of a database schema 
and all its envisaged usages (to a meta-mathematician the ER schema notion equates to a \term{theory} of some kind
and an ER model to a theory and all its instances i.e. all its models\footnote{This is my first and last usage of the term \term{model} 
with the meaning the term has in mathematical logic; for the remainder of this paper it will have the meaning as used in data modelling.}).  We define the conditions  for an ER model to be purely \term{logical} in the sense used in
the term \term{logical data design} and, in contrast, the conditions for an ER model to be \term{physical}. The definitions are such that
a \term{physical ER model} is pretty much the same thing as a  relational database schema. We define the first-cut Chen mapping for generating a first 
cut physical ER model from a logical ER model and then develop this definition in a way that reduces redundancy in the generated physical model by taking account of commuting and near commuting diagrams of relationships in the logical model
and thereby establish a revised Chen mapping $\logtophys$ so that for any logical ER model $\genericmodel$, $\logtophys(\genericmodel)$ is a physical ER model. Finally we define what it is for a logical model to be well-formulated and prove that if $\genericmodel$ is a well-formulated logical ER model then 
the generated physical ER model $\logtophys(\genericmodel)$ is in Boyce-Codd normal form (BCNF). 

\newpage
\section{Definition of ER model}
The functional view of data summarised above\commentary{No it isn't.} taken with the requirement of specifying the attributes and relationships from which entities may be identified suggests a mathematical definition of an ER-schema  as  follows:

\begin{definition}
An \term{ER-schema} $\genericmodel$ is a directed graph having the following additional structure:

\begin{enumerate} [(i)]
\item{a distinguished node $\veee$ for which there are no outgoing edges and which represents the type of all scalar values, }

\item{a distinguished acyclic subset $I$ of edges, called the identifying edges, such that
for every node $a$ other than $\veee$ there is a non-empty set $I_a$ of identifying edges with domain $a$. 
}
\end{enumerate}

\end{definition}

If $\genericmodel$ is an ER-schema (or an ER-model which, as we define below, 
includes an ER-schema) then the nodes of $\genericmodel$ other than $\veee$ we say are entity types and we denote by $\et$.

The set $\attr{a}$ of attributes of an entity type $a$ is defined as the set of edges that have $a$ as source and  $\veee$ as destination. 

A database instance will be described as a collection of sets 
and functions in that (i) for each entity type $a$ there is defined in 
the database instance a set $E_a$ of entities of type $a$;
(ii) for each edge $a \morph b$
there is defined a possibly partial function $f_r : E_a \rightarrow E_b$. 
In this functional view, an instance of such a relationship $r$ is defined to be a pair 
of entities $e,e'$ such that $f_r(e)=e'$. For each attribute $attr$
of entity type $et$ there is defined in the database instance a function
$f_{attr}: E_{et} \rightarrow \Veee$. \\

\noindent A simple navigation path through an ER schema  is a
sequence of  $n$ edges:
$\overset{r_1}{x_0 \morph   x_1} \overset{r_2}{\morph} x_2 ... \overset{r_n}{\morph} x_n$.  $x_0$ is said to be the source of the path and $x_n$ is said to be the destination of the path. 

\noindent For any database instance $E$ we can  extend  the definition of
$E_f$, for edges $f$,  so that to every path $p$, $p: a \rightarrow b$,  we have defined a function $E_p: E_a \rightarrow E_b$. From the initial definition of $E_f$ that applies to 
edges the definition proceeds recursively as follows: 
\begin{enumerate} [(i)]
\item{  For each entity type $a$, $E_{\langle \rangle}: E_a \rightarrow E_a$ is defined to be the identity function.
}
\item{   if $p$ is a navigation path $p: a \rightarrow b$ and $f$ is an edge $p: b \rightarrow c$ then $E_{\langle p,f \rangle}$ is 
is defined to be the functional composition $E_p \circ E_f$.
}
\end{enumerate}

We can extend this notation further and define $E$ on n-tuples of paths so that if 
$\tuple{p_1,...p_n}$ is an n-tuple of paths from entity type $a$ then in an instance E
the function  $E_{\tuple{p_1,...p_n}}$ is defined to be the function mapping each element $e$ 
of $E_a$ to 
$\tuple{E_{p_1}(e),...E_{p_n}(e)}$.

\begin{definition}
If $s$ is a set and if $f_{i, 1\leq i \leq n}$ is a family of partial functions, $f_i: s \rightarrow s_i$   for some sets $s_{i, 1 \leq i \leq n}$,  then
we will say that the family of functions $f_{i, 1\leq i \leq n}$, is \term{jointly injective} if the partial function $\langle f_1,...f_n\rangle: s \rightarrow
s_1 \times ... \times s_n $ is injective. In this case the partial function $\langle f_1,...f_n\rangle: s \rightarrow
s_1 \times ... \times s_n $ is also invertible i.e. iff there is a partial function $inv_{\langle f_1,...f_n\rangle} : s_1 \times ... \times s_n \rightarrow s$ such that
(i) for all $x \in s$, $inv_{\langle f_1,...f_n\rangle}(\langle f_1(x),...f_2(x) \rangle ) = x$ and (ii) if $y \in s_1 \times ... \times s_n $ and
$y \notin img(\langle f_1,...f_n\rangle)$ then $inv_{\langle f_1,...f_n\rangle}(y)$ is undefined. \\
\end{definition}

\noindent We can now define database instance as follows:
\begin{definition}
\noindent A \term{database instance}  of an ER schema is
a set of entities $E_x$ for each node $x$ of the graph of the schema and 
a partial function $E_r : E_x \rightarrow E_y$ for each edge of the graph $r:x \rightarrow y$ 
such that $E_\veee=\Veee$
and such that 
for each entity type $x$ if $I_x$ is the subset of all the outgoing and identifying edges
of $x$ then for each $e \in I_x$ the function $E_e$ is total and
the set of functions $\setsuchthat{E_e}{e \in I_x}$, is jointly injective.
\end{definition}

\begin{definition}
\noindent An \term{ER model} is an ER schema and a set of database instances of the schema. \\
\end{definition}



\subsection{Path equivalence and subsumption}

\noindent If $r$ and $s$ are paths both having source $a$ and destination $b$ then we will say $r \leq s$ iff in all instances E, for all 
entities $e \in E_a$, if $E_r(e)$ is defined then $E_s(e)$ is defined and $E_r(e)=E_s(e)$. \\

\noindent If $r$ and $s$ are paths both having source $a$ and destination $b$ then we will say $r \simeq s$ iff $r \leq s$ and $s \leq r$. \\

\noindent With these definitions,  the (meta-relationship) $\leq$ is a partial order on the classes of equivalent paths. \\

\noindent For paths $r$ and $s$ we define $r < s$ to be equivalent to $r \leq s$ and not $r \simeq s$. \\

\noindent Figure \ref{foreignkeygraph} gives an example of equivalent paths from an entity model\footnote{Careful because model is slightly different in choice of identifiers and this is significant - so not quite the same model.} discussed in part one of this paper.


\begin{definition}
Say that a simple path $\tuple{r_0,r_1,...r_n}$ \textit{is subsumed by} a simple path 
$\tuple{s_0,s_1,...s_m}$ iff $m \geq 1$ and either:
\begin{enumerate} [(i)]

\item $\tuple{r_0,r_1,...r_n} \simeq  \tuple{s_0,s_1,...s_m}$ and 
\commentary{In most general case this will become not $s_1$ uses $s_2$ ... uses $s_m$.}
for some $j$, $1 \leq j \leq m$, $s_j$ is not an identifying edge. \\

 \hspace{1cm} or:
\item $\tuple{r_0,r_1,...r_n} <  \tuple{s_0,s_1,...s_m}$ and $r_0 \neq s_0$.
\end{enumerate}
\end{definition}

\begin{figure} [h]
\begin{center}
\begin{tabular}{c c}
$
\begin{array}{cp{0.75cm}cp{0.75cm}c}
   \Rnode{fk}{fk}     & & \Rnode{t}{t} & & \Rnode{v}{v} \\[1.2cm]     
	 \Rnode{fkc}{fkc}   & & \Rnode{c}{c} & &               
\end{array}
$
\ncarr{fk}{t} 
\alabel{S_1}
\ncarr{t}{v} 
\alabel{tN}
\idcomp
\ncarr{c}{v} 
\blabel{cN}
\idcomp
\ncarr{fkc}{c}
\blabel{R_0}
\ncarr{fkc}{fk}
\alabel{S_0}
\idcomp
\ncarr{c}{t}
\blabel{R_1}
\idcomp
\ncarr[50]{fk}{v}
\alabel{FkN}
\idcomp
\ncarr[-90]{fkc}{v}
\blabel{SeqN}
\idcomp
& \footnotesize
\begin{tabular}{c p{1.5cm} p{4cm}}
KEY && \\
\hline
t & table & Having identifying attribute tN the name of the table. \\
c & column & Identified by a combination of column name cN and relationship $R_1$ to the table it is a column of.\\
fk & foreign key & Identified by its name $FkN$.\\
fkc & foreign key column & Identified by relationship $S_0$ to the foreign key it is a part of and its sequence number $SeqN$ i.e. the position it appears in within the foreign key. \\
\end{tabular} 
\end{tabular}
\end{center}
\caption{Example of path equivalence - the path $\tuple{R_0,R_1}$ is equivalent to path $\tuple{S_0,S_1}$.}
\label{foreignkeygraph}
\end{figure}

\begin{figure} [h]  % student advisor
\begin{center}
\begin{tabular}{c c}
$
\begin{array}{cp{0.05cm}c  p{0.05cm}c p{0.5cm}c}
                & & \Rnode{d}{d} & &              & &             \\ [0.3cm]
								& &              & &              & & \Rnode{v}{v} \\ [0.6cm]     
	 \Rnode{s}{s} & &              & & \Rnode{p}{p} & &             
\end{array}
$
\ncarr{s}{d} 
\alabel{S_1}
\idcomp
\ncarr{d}{v} 
\alabel{Id}
\idcomp
\ncarr{p}{v} 
\blabel{PNo}
\idcomp
\ncarr{p}{d} 
\blabel{R_1}
\idcomp
\ncline[linestyle=dashed,nodesepA=\arrnodesepA,nodesepB=\arrnodesepB]{->}{s}{p} 
\blabel{R_0}
\ncarr[-90]{s}{v} 
\blabel{sNo}
\idcomp
& \footnotesize
\begin{tabular}{c p{1.5cm} p{4cm}}
KEY && \\
\hline
d & department & Having identifying attribute Id the department identifier. \\
s & student & Identified by relationship $S_0$ to department enrolled in and  attribute student number SNo. \\
p & professor & Identified by their relationship $R_1$ to a department and their professor number attribute pNo yyy \\
R0 & advised by & Represents the optional relationship between a student and a professor.\\
\end{tabular} 
\end{tabular}
\end{center}
\caption{Example of path  $\tuple{R_0,R_1} < \tuple{S_1}$. This example is based on one given in part one of this document. Here we specify that a student optionally has an advisor (suppose that the advisor is selected part way through a course). As before we assume that an advisor must be a professor of the department in which the student is enrolled. }
\label{studentadvisorgraph}
\end{figure}

\subsection{Jointly Injective Sets of Functions}
\begin{lemma}
\label{jointlyinjectivecomposition}
If $A$ is a set and $I$  a jointly injective set of functions with domain $A$, if $F \in I$, $F: A \morph B$ is a function,
and if $J$ is a jointly injective set of functions with domain $B$ then the set of functions
$(I \backslash \set{F}) \cup \setsuchthat{F \circ G}{G \in J}$ is jointly injective.
\end{lemma}
\begin{proof}

\end{proof}


\begin{lemma}
\label{jointlyinjectivefactorisation}
If $A$ is a set and $I$  a set of functions with domain $A$, if $F \in I$, $F: A \morph B$ is a function,
and if $J$ is a jointly injective set of functions with domain $B$ then if the set of functions
$(I \backslash \set{F}) \cup \setsuchthat{F \circ G}{G \in J}$ is jointly injective then the
set $I$ is jointly injective.
\end{lemma}
\begin{proof}
Suppose $x_1,x_2 \in A$ and that for all $f \in I$, $f(x_1)=f(x_2)$. We need show that $x_1=x_2$.
Because $(I \backslash \set{F}) \cup \setsuchthat{F \circ G}{G \in J}$ is jointly injective
it suffices to show that 
\begin{enumerate}[(i)]
\item
for all $f \in I \backslash \set{F}$, $f(x_1)=f(x_2)$, 
\item that for all $f \in \setsuchthat{F \circ G}{G \in J}$, $f(x_1)=f(x_2)$
\end{enumerate}
(i) follows directly from the initial assumption. 
(ii) follows because for such an $f$, 
\begin{align*}
f(x_1)&=G(F(x_1) & & \\
      &=G(F(x_2) & & \mbox{from the initial assumption since }F \in I \\
			&=f(x_2). & &
\end{align*}
\end{proof}


\subsection{Identifying Sets}

The following definition takes the place of that of super key in the relational model:
\begin{definition}
A set of paths $P$  within a model $\genericmodel$ is said to be a \term{mono-source} at entity type $a$
iff each path $p \in P$ has domain $a$ and such that in all instances E, 
(i) the function $E_p$ is total, for each $p \in P$, and (ii) the set of functions
$\setsuchthat{E_p}{p\in P}$ is a jointly injective.
\end{definition}

From the definition of ER model it follows that the set of outgoing edges of an entity type 
$a$ in a model \genericmodel\ is a mono-source. 
By piecing together mono-sources further mono-sources can be constructed 
as we now show. First we need these definitions:

\subsection{Composition}

\begin{lemma}
\label{identifyingsetdeduction}

In a model \genericmodel, if $i$ is a source with domain $a$,
if $f \in i$, $f: a \morph b$, 
and if $j$ is a mono-source with domain $b$
then 
$i$ is a mono-source iff $(i \backslash \set{f}) \cup \setsuchthat{f \circ g}{g \in j}$ is a mono-source.
\end{lemma}
\begin{proof}
First note that from the definition of database instance it follows that 
\begin{equation}
\label{eequivalentsets}
\setsuchthat{E_e}{e \in (i \backslash \set{f}) \cup \setsuchthat{f \circ g}{g \in j}}
= \setsuchthat{E_e}{e \in i} \backslash \set{E_f} \cup \setsuchthat{E_f \circ E_g}{g \in j}
\end{equation}

We can show that if $i$ is a mono-source 
then $(i \backslash \set{f}) \cup \setsuchthat{f \circ g}{g \in j}$ is a mono-source
by showing that for any instance $E$ of \genericmodel\ the family of functions 
$\setsuchthat{E_e}{e \in (i \backslash \set{f}) \cup \setsuchthat{f \circ g}{g \in j}}$
is jointly injective. Because of (\ref{eequivalentsets}) this follows by applying lemma \ref{jointlyinjectivecomposition} with $I$ being $\setsuchthat{E_e}{e \in i}$,
$F$ being $E_f$,  and $G$ being $\setsuchthat{E_g}{g \in j}$.

\textit{Vice-versa}, we can show that if $(i \backslash \set{f}) \cup \setsuchthat{f \circ g}{g \in j}$ is a mono-source then $i$ is a mono-source by applying lemma \ref{jointlyinjectivefactorisation} 
with, as above, $I$ being $\setsuchthat{E_e}{e \in i}$,
$F$ being $E_f$,  and $G$ being $\setsuchthat{E_g}{g \in j}$.
\end{proof}

\begin{definition}
$\bar{I}$ is the closure of $I$ under composition.\commentary{Need expand on this.}
\end{definition}

\subsubsection{Fully Factored}

\begin{definition}
In an entity model \genericmodel\ if $a$ is an entity type then say that
the set $I_a$ can be \term{factored} iff for some subset $\set{h_1,...h_n} \subset I_a$
there is an path $f:a \morph b$ and a set of paths sourced at $b$, $\set{g_1,...g_n} \in \bar{I}$
such that for each $i$, $1 \leq i \leq n$, $f \circ g_i \simeq h_i$. 
\end{definition}

Note that if a model \genericmodel\
factorises at $a$ then the factorisation consists  
of a base set of edges: $h=I \backslash {h_1,...h_n}$, a mediating path $f:a \morph b$ and a remainder 
set $j$ paths sourced at $b$, $j \in \bar{I}$, 
such that $I_a \simeq h \cup \setsuchthat{f\circ g}{g \in j}$.

\begin{definition}
If \genericmodel\ is a model and if there is a factorisation at entity type $a$ with
base set $h$, mediating path $f: a \morph b$ and remainder $j \in \bar{I}$ then define
a factored model $genericmodel'$ determined by the factorisation to be the model
whose underlying graph is the graph of \genericmodel\ with edges $h_1,...h_n$ removed 
(database instances restricted) and
an edge $k$ added, $k:a \morph b$, each database instance $E$ extends to $E'$, $E'_k = E_f$.
Identifying sets of $genericmodel'$ are exactly as for \genericmodel\ except for at the entity
type $a$ where the identifying set $I_a$ in $\genericmodel'$ is defined to be $h \cup \set{k}$.
Note that by lemma \ref{identifyingsetdeduction} the modified $E'$ is a database instance because
the family 
$\setsuchthat{E'_e}{e \in \set{h \cup set{k}}}$ is jointly injective because 
$\setsuchthat{E'_e}{e \in \set{h \cup set{k}}} =\setsuchthat{E_e}{e \in \set{h \cup set{f}}}$
and in model \genericmodel, $h \cup set{f}$ is a mono-source because 
$h \cup \set{f} \backslash f \cup \setsuchthat{f \circ g}{g \in j}$ is a mono-source and $j$ is a mono-source.
\end{definition}

\begin{definition}
If $a$ is an entity type in an entity model \genericmodel\ then a \term{primary key path}
\commentary{Need show equivalence of this and alternate definitions.}
of $a$ is any path $p:a \morph v$ consisting entirely of identifying edges. 
\end{definition}

\begin{definition}
If $a$ is an entity type in an entity model \genericmodel\ then define the abstraction
level of $a$ to be the sum of the lengths of the primary key paths sourced at $a$.
\end{definition}


\begin{definition}
Define  the abstraction level of a model $genericmodel$ to be
the sum over all entity types $a$ of the abstraction level of $a$.
\end{definition}

\begin{lemma}
If $\genericmodel'$ is a factorisation of model $\genericmodel$ then abstraction level 
of $\genericmodel'$ is greater than abstraction level of $\genericmodel$ and the number of edges
is not increased. 
\end{lemma}
\begin{proof}
\end{proof}

\begin{definition}
Define an entity model \genericmodel\ to be fully-factored iff no entity type $a$ can be factored.
\end{definition}

\begin{definition}
If \genericmodel\ is a model then say that a $\genericmodel'$ is a fully-factored 
equivalent to \genericmodel\
if it results from successive factorisations of \genericmodel\ until the resulting model can no longer be
factorised. 
\end{definition}

\begin{lemma}
Every model \genericmodel\ has a fully factorised equivalent. 
\end{lemma}
\begin{proof}
We need to show that the factorisation process will terminate. 
to do this note that we can put a (crude) bound on the abstraction level of an entity model
of number of entity types multiplied by the square of the  number of edges
\commentary{Need revise this most likely}.  Because the number of nodes remains constant during
factorisation and because the number of edges does not increase this bound can be calculated
for the model \genericmodel\ and serves as an upper bound for the abstraction level of 
any successive factorisation of \genericmodel\. Since factorisation increases abstraction level
and there is an upper bound to abstraction level then the process cannot continue indefinitely. 
\end{proof}

Show that if $I' = (I \backslash H) \cup \set{H_0 \cup \set{f}}$ then $\bar{I'} = \bar{I} \cup \set{H_0 \cup \set{f}}$. \commentary{Wrong! But idea was that by lemma 
\ref{identifyingfactorminimal} 
$H_0 \cup \set{f}$ is minimal which helps get that if model well-formed then its factored
model is well formed.}\\


This suggests $\tuple{G,I}$ and $\tuple{G,I'}$ are equivalent i.e. have exactly the same models\commentary{Does it?}.\\

Finally show that $\tuple{G,I'}$  can be pruned to $\tuple{G',I'}$ by removal of edges $\set{h_1,...h_n}$.\\

This establishes that every model $\tuple{G,I}$ has an equivalent fully factored model.
In fact a model has one or more fully-factored 'equivalents' not just one.
 \commentary{Not so!}.


\subsubsection*{Extended 17 July 2019}
\begin{definition}
Define the core graph $C(\genericmodel)$ of a model \genericmodel\ to be the graph whose edges are 
those edges $e$
of (the underlying graph) of \genericmodel\ such that there does not exist a path $p$ of length
greater than 1 such that $p \simeq e$. 
\end{definition}
\begin{definition}
Define two models \genericmodel\ and $\genericmodel'$ to be equivalent iff (i) $C(\genericmodel)=C(\genericmodel')$ and (ii) preinstances of $schema(\genericmodel)$, 
equivalently of $schema(\genericmodel')$, \commentary{Sharpen this.}
is an database instance of $schema(\genericmodel)$ iff it is a database instance of
$schema(\genericmodel')$ and (iii) the set of instances when restricted to the core are identical sets.
\end{definition}
\begin{lemma}
If \genericmodel\ is an ER model then there is an equivalent model which is fully-factored.
\end{lemma}
\begin{proof}
Use lemma \ref{identifyingsetdeduction}.
\end{proof}
\begin{lemma}
If \genericmodel\ is an ER model then there is an equivalent model which is primarily keyed.
\end{lemma}
\begin{proof}
Again, use lemma \ref{identifyingsetdeduction}.
\end{proof}

\subsubsection{Primarily keyed}

\begin{definition}
$\bar{I}_v$ is the subset of $\bar{I}$ comprising all sets of identifying edges all of whose
edges have destination $\veee$. \commentary{Need better notation and better explanation.}.
\end{definition}


\subsubsection{Minimality}
\begin{lemma}
\label{identifyingfactorminimal}
In a model \genericmodel, if $i$ is a source with domain $a$,
if $f \in i$, $f: a \morph b$, 
and if $j$ is a mono-source with domain $b$
then  if $(i \backslash \set{f}) \cup \setsuchthat{f \circ g}{g \in j}$ is a minimum mono-source
then $i$ is a minimum mono-source.
\end{lemma}
\begin{proof}
We assume that $(i \backslash \set{f}) \cup \setsuchthat{f \circ g}{g \in j}$ is a mono-source and that no subset of it is a mono-source.
By lemma \ref{identifyingsetdeduction} it follows that $i$ is a mono-source we need to show that
for no edge $e \in i$ is $i \ \set{e}$ a mono source. Assume to the contrary that there is such an $e$ then  either $e = f$ or else
$e \in i \backslash \set{f}$. In the first case $(i \backslash f)$ is a subset of  $(i \backslash \set{f}) \cup \setsuchthat{f \circ g}{g \in j}$ which is a mono-source which contradicts the initial assumption. In the second  case 
by lemma \ref{identifyingsetdeduction} since $i \backslash \set{e}$ is a mono-source it follows that
$((i \backslash \set{e})\backslash \set{f}) \cup \setsuchthat{f \circ g}{g \in j}$ is a mono-source which again is to say that a subset
of $(i \backslash \set{f}) \cup \setsuchthat{f \circ g}{g \in j}$ is a mono-source contradicting the initial assumption.
We conclude that no subset of $i$ is a mono-source.
\end{proof}

\newpage

\noindent
Consider that the various database normal forms (3NF, BCNF, 4NF, 5NF and the like) each 
prescribe that a database schema be complete in some way as a description of the facts of its instances\footnote{Essentially
 because being good as a schema is to be a good theory and a good theory is one that is a good fit to the facts.} and observe 
in particular that BCNF can be paraphrased as saying that those relationships (i.e. functional dependencies) that exist in the data ought to be \term{represented} in the schema\footnote{21/02/2019 Is this not the representation principle?}. These considerations motivate the definitions which now follow and conclude with the definition of a \term{well-formulated} entity model. This definition generalises that of a relational schema being in Boyce-Codd Normal Form (BCNF). 

\newpage
\subsection{Referential Inclusion Dependencies}

\commentary{aka referential integrity constraints/foreign keys/foreign key constraints}

\begin{definition}
If $\genericmodel$ is an entity model, 
if $a$ and $b$ are entity types of  $\genericmodel$ and  if \qntuple\
is an identifying tuple with respect to $b$,
if \fntuple is a tuple of outgoing paths from entity type $b$  
so that we have the following diagram of paths in $\genericmodel$
\setlength{\arraycolsep}{.2cm}
\begin{center}
$
\begin{array}{cp{2cm}ccp{2cm}c}
             & &         & \Rnode{b1}{b_1} &&               \\ [0.5cm]
						 & &         & \Rnode{b2}{b_2} &&               \\ [0.2cm]
\Rnode{a}{a} & &         &                 &&  \Rnode{b}{b} \\ [-0.2cm]						
             & &         &    \vdots       &&               \\ [0.2cm]
             & &         & \Rnode{bn}{b_n} &&               \\ 
\end{array}
$
\simplepatha{$f_1$}{a}{b1}
\simplepatha{$f_2$}{a}{b2}
\simplepathb{$f_n$}{a}{bn}
\simplepathb{$q_1$}{b}{b1}
\simplepathb{$q_2$}{b}{b2}
\simplepatha{$q_n$}{b}{bn}
\end{center}
then say that $a$ represented by $\fntuple$ 
has a referential inclusion dependency with $b$ represented by $\qntuple$, and for which we shall summarily write:
$$
\incd{a}{f_1,...f_n}{b}{q_1,...q_n},
$$
iff in all instances $E$ of $\genericmodel$,
$img(E_{\fntuple}) \subseteq img(E_{\qntuple})$. 
\end{definition}

\begin{definition}
We say that a path $p:a \morph b$ represents a referential inclusion dependency
$\incd{a}{f_1,...f_n}{b}{q_1,...q_n}$  in an ER model $\genericmodel$ 
  in all instances $E$ of $\genericmodel$, $E_{\fntuple} \circ E_{\qntuple}^{-1}=E_p$.
\end{definition}
We say that an referential inclusion dependency in model \genericmodel\ is represented provided that
there exists a path which represents it. 
\begin{lemma}
\label{refinclusionlemma}
A referential inclusion dependency
$\incd{a}{f_1,...f_n}{b}{q_1,...q_n}$  in an ER model $\genericmodel$ is  represented 
by path $p:a \morph b$ in $\genericmodel$ iff  \foreachi, $p \circ q_i \simeq f_i$.
\end{lemma}
\begin{proof}
\begin{align*}
\text{In the model \genericmodel,}
            &\text{in each instance $E$, }E_p = E_{\fntuple} \circ E_{\qntuple}^{-1}  \\
\text{iff } & \text{in each instance $E$, } E_p \circ E_{\qntuple} = E_{\fntuple}  
                        && \text{because } E_{\qntuple} \text{ injective and total}   \\
\text{iff } & \text{in each instance $E$, } \tuple{E_p \circ E_{q_1},...E_p \circ E_{q_n}} 
                                                      = \tuple{E_{f_1},...E_{f_n}}
									                                            && \text{ by defn. of }E \\
\text{iff } & \text{in each instance $E$, \foreachi, } E_p \circ E_{q_i} = E_{f_i} 
                                                              && \text{because tuples are equal iff they are pointwise equal}  \\
\text{iff } & \text{\foreachi, } p \circ q_i \simeq f_i          && \text{by defn of } \simeq.
\end{align*}
\end{proof}


\begin{categoricalaside}
If an ER schema is represented as a category with finite products (\textit{a la} Johnstone \textit{et al}) then
a referential inclusion dependency is a  diagram
\begin{center}
$
\begin{array}{cp{0.75cm}c}
   \Rnode{a}{a}     & & \Rnode{x}{x}  \\[1.2cm]     
	                  & & \Rnode{b}{b}  
\end{array}
$
\ncarr{a}{x} 
\alabel{f}[0.33]
\ncarr{b}{x}
\blabel{m}[0.3]
\idcomp
\end{center}
\noindent
in \cat{C} such that in all instance functors $F$, 
$F(f)$ factors through $F(m)$.

Such a referential inclusion dependency is explicitly represented iff
 $f$ factors through $m$ i.e. there is an $f_0: a \morph b$ in \cat{C} such that 
$f_0 \circ m =f$. Note that because $m$ is monic then such an $f_0$ is the unique such morphism and if in some instance $F$,
$e: F(a) \morph F(b)$ is a function such that $e \circ F(m) = F(f)$ then $F(f_0)=e$. 
\end{categoricalaside}

\begin{definition}
Say that an inclusion dependency $\incd{a}{x_1,...x_n}{b}{q_1,...q_n}$ is \textit{simple}
iff each $q_i$ is a singleton path, i.e. is simply an edge. 
\end{definition}

\begin{lemma}
\label{simplerepresentationlemma}
If in an ER model \genericmodel\ all simple referential inclusion dependencies
have representations  then all referential inclusion dependencies have representations. 
\end{lemma}
\begin{proof}
Proof by induction TBD. \commentary{Start by drawing a diagram of the inductive step.} 
\end{proof}

\subsection{Functional Dependencies}

\begin{definition} %functional dependency
In an entity model $\genericmodel$  
if for some $n \geq 1$, $a$, $b_{i, 1 \leq i \leq n}$,  and $c$ are entity types and 
if  $x_{i, 1 \leq i \leq n}$, and $y$ are simple paths such
that for each $i$, $x_i : a \rightarrow b_i$, and such that $y: a \rightarrow c$ 
as shown here:
\setlength{\arraycolsep}{.2cm}
\begin{center}
$
\begin{array}{cp{2cm}cc}
             & &         & \Rnode{b1}{b_1} \\ [0.5cm]
						 & &         & \Rnode{b2}{b_2} \\ [0.6cm]
						 & & \vdots  &                 \\ [0.2cm]
\Rnode{a}{a} & &         & \Rnode{bn}{b_n} \\ [1.0cm]
             & &         & \Rnode{c}{c}   \\
\end{array}
$
\simplepatha{$x_1$}{a}{b1}
\simplepatha{$x_2$}{a}{b2}
\simplepatha{$x_n$}{a}{bn}
\simplepathb{$y$}{a}{c}
\end{center}



\noindent 
then path $y$ is said to be \term{functionally dependent} on the set of paths $\{x_1,...x_n\}$, 
for which  we write  \sfd{x_1,...x_n}{y},
iff
 in each instance $E$ there exists a  partial 
function $f_E: E_{b_1} \times E_{b_n} \rightarrow E_c$ 
\noindent such that 
domain of $f_E \subseteq img(E_{\langle x_1,... x_n \rangle})$ 
and  
$E_{\xntuple} \circ f_E = E_y$ 
\begin{center}
$
\begin{array}{cp{2cm}ccp{0.5cm}cc}
						    & &         & \Rnode{Eb1}{E_{b_1}}& &                            &        \\ [0.6cm]
						    & &         & \Rnode{Eb2}{E_{b_2}}& &                            &        \\ [0.6cm]
						    & &\vdots  &                      & &                            &        \\ [0.2cm]												
\Rnode{Ea}{E_a} & &         & \Rnode{Ebn}{E_{b_n}}& & \Rnode{Jnctn}{}&  \\ [1.0cm]
						    & &         & \Rnode{Ec}{{E_c}}   & &                            &        \\
\end{array}
$
\simplepatha{$E_{x_1}$}{Ea}{Eb1}
\simplepatha{$E_{x_2}$}{Ea}{Eb2}
\simplepatha{$E_{x_n}$}{Ea}{Ebn}
\simplepathb{$E_y$}{Ea}{Ec}
\nchmarr[15][45]{Eb1}{Ebn}{Jnctn}{Ec}
\naput[npos=-0.1]{$f_E$}
\ncarc[arcangle=15]{Eb2}{Jnctn}
\end{center}
\end{definition}

\begin{remark}
In the above definition, if within an instance $E$ there exists such a partial function $f$ such that
$E_{\xntuple} \circ f_E = E_y$ then $f$ will be the unique such partial function. For if 
partial function $f'$ is another such then given a $\tuple{E_{x_1}(e),...E_{x_n}(e)} \in img(E_{\tuple{x_1,...x_n}})$
we have that $f(\tuple{E_{x_1}(e),...E_{x_n}(e)})=E_y(e)=f'(\tuple{E_{x_1}(e),...E_{x_n}(e)})$.
\end{remark}

\begin{definition}
A functional dependency \sfd{x_1,...x_n}{y} is said to be \term{trivial} if $y\simeq x_i$, for some $i$, $1 \leq i \leq n$.
\end{definition}

\begin{definition}
In an entity model $\genericmodel$, if
$e$ is an entity type and $\set{x_1,...x_n}$ and $\set{y_1,...y_m}$ are sets of simple paths with source $a$
then we say the set $\set{y_1,...y_m}$ \textit{is functionally dependent on the set} $\set{x_1,...x_n}$ and write
\fd{x_1,...x_n}{y_1,...y_m} 
iff  each $y_j$, $1 \leq j \leq m$, is functionally dependent on $\set{x_1,...x_n}$.
\end{definition}
\begin{definition} %transitive
In an entity model $\genericmodel$, a functional dependency $\set{x_1,...x_n} \morph z$
is said to be \term{transitive} if there exists a set of paths $\{y_1,...y_{m}\}$ such that
$\set{x_1,...x_n} \morph \set{y_1,...y_{m}}$ and $\set{y_1,...y_{m}} \morph y$ but not
$\{y_1,...y_{m}\} \morph \{x_1,...x_n\}$.
\end{definition}
\begin{definition} %intransitive
In an entity model $\genericmodel$, a functional dependency $\set{x_1,...x_n} \morph y$
is said to be \term{intransitive} if it is not transitive.
\end{definition}
\begin{lemma}
\label{transitiveinjectivelemma}
If $\set{x_1,...x_n} \morph \set{y_1,...y_{m}}$ then if in an instances $E$ the function $E_{\tuple{y_1,...y_{m}}}$ is 
injective then the function $E_{\tuple{x_1,...x_n}}$  is injective.
\end{lemma}
\begin{proof}
Follows from the definition of functional dependency that for each $j$, $1 \leq j \leq m$  there is a function ${f_j}$,  such that
$E_{y_j}=E_{\tuple{x_1,...x_n}}\circ f_j$. Therefore there is a function $f=\tuple{f_1,...f_m}$ such that
$E_{\tuple{y_1,...y_m}}= E_{\tuple{x_1,...x_n}}\circ f $. Therefore since  the function $E_{\tuple{y_1,...y_{m}}}$ is 
injective then the function $E_{\tuple{x_1,...x_n}}$  is injective.
\end{proof}




\iffalse
\begin{definition} %elementary
In an entity model $\genericmodel$, a functional dependency $\{x_1,...x_n\} \morph y$
is said to be elementary if there is no  subset $X' \subset$, such that $X' \morph y$.
\end{definition}
\fi

\begin{figure}[h]
\begin{center}
\begin{tabular}{p{3.0cm} c p{1cm} c}
The dependency of &\input{pickExampleTransitiveDependencyRHS} 
                    & on & \input{pickExampleTransitiveDependencyLHS} \\[0.5cm]
										follows from \\[0.5cm]
the dependency of & \input{pickExampleTransitiveDependencyRHS} & on    &
\input{pickExampleTransitiveDependencyIntermediate}        \\[0.5cm]
and from \\[0.5cm]
the dependency of & 
\input{pickExampleS0S1}
& on&
\input{pickExampleTransitiveDependencyIntermediateLHS} 
\end{tabular}
\caption{Example of a Transitive Functional Dependency based on the example in figure \ref{pickexample}}
\end{center}
\end{figure}



\begin{definition}
\noindent In an entity model $\genericmodel$  
if for some $n \geq 1$, $a$, $b_{i, 1 \leq i \leq n}$,  and $c$ are entity types and 
if  $x_{i, 1 \leq i \leq n}$, and $y$ are simple paths such
that there is a \commentary{Removed elementary intransitive}functional dependency $\{x_1,...x_n\} \morph y$
 then the functional dependency $\{x_1,...x_n\} \morph y$ is said to be \term{represented} in the ER model $\genericmodel$ iff  there exists an entity type $d$ and 
an identifying tuple of simple paths with respect to
$d$, $\qntuple$, such that $\incd{a}{x_1,...x_n}{d}{q_1,...q_n}$, and a simple
path $z=\langle z_1,...z_l \rangle$ such that $z:d\rightarrow c$, for some $l \geq 0$ as here:


\setlength{\arraycolsep}{.2cm}
\begin{center}

$
\begin{array}{cp{2cm}c p{2cm} c}
             &  & \Rnode{b1}{b_1} & &               \\ [0.7cm]
						 &  & \Rnode{b2}{b_2} & &               \\ [0.4cm]
						 &  &     \vdots      & &               \\ [0.2cm]
\Rnode{a}{a} &  &                 & & \Rnode{d}{d}  \\ [-0.2cm]
             &  & \Rnode{bn}{b_n} & &               \\ [0.9cm]
             &  & \Rnode{c}{c}    & &               \\
\end{array}
$
\simplepatha{$x_1$}{a}{b1}
\simplepatha{$x_2$}{a}{b2}
\simplepatha{$x_n$}{a}{bn}
\simplepathb{$y$}{a}{c}
\simplepathb{$q_1$}{d}{b1}
\simplepathb{$q_2$}{d}{b2}
\simplepathb{$q_n$}{d}{bn}
\simplepatha{$z$}{d}{c}
\end{center}


and
\commentary {Removed that $z_1$ is not identifying but expect to prove not identifying.}         
such that in all instances $E$, 
$\tuple{ E_{x_1},...E_{x_n}} \circ inv_{E_{\tuple{q_1,...q_n}}}\circ E_{\tuple{z_1,...z_l}} = E_y$
\begin{center}
$
\begin{array}{cp{0.75cm}cp{0.55cm}c}
               &&\Rnode{Eb1}{E_{b_1}}   &&                      \\ [0.6cm]
               &&\Rnode{Eb2}{E_{b_2}}   &&                      \\ [0.2cm]
\Rnode{Jnctn}{}&&  \vdots               &&\Rnode{RightJnctn}{}  \\ [0.1cm]							
               &&\Rnode{Ebn}{E_{b_n}}   &&                      \\ [0cm]
							 &&                       &&\mbox{ }\Rnode{Ed}{E_d}       \\ [0.5cm]
               &&\Rnode{Ec}{{E_c}}      &&                      \\
\end{array}
$
\nchmarr[-20][-45]{Eb1}{Ebn}{Jnctn}{Ec}
\nbput[npos=0.2]{$f_E$}
\ncarc[arcangle=-20]{Eb2}{Jnctn}
\nchmarr[20][15]{Eb1}{Ebn}{RightJnctn}{Ed}
\naput[npos=-0.2]{$ inv_{E_{\qntuple}}   $}
\ncarc[arcangle=20]{Eb2}{RightJnctn}
\ncarc[arcangle=15]{->}{Ed}{Ec}
\naput[npos=0.4]{$E_{\langle z_1,...z_n \rangle}$}
\end{center} 
\end{definition}
\newpage
\begin{definition}
\noindent An ER model $\genericmodel$ is \term{well-formulated} 
 iff 
\begin{enumerate} [(i)]
\item{
\commentary{Was: for each entity type $a$, there is no proper subset $J$ of any set of identifying paths leaving $a$ that  is a mono-source i.e. for all $K \in \bar{I}$ there does not exist $J \subset K$ such that 
$K$ is a mono-source}
for all $K \in \bar{I}$, for all $e \in K$, if $K \backslash \set{e}$ is a mono-source then
there exists $k \in K$ such that $k \simeq e$,
}
\item{ 
all referential inclusion dependencies\footnote{Equivalently, by lemma
\ref{simplerepresentationlemma}, sufficient that all simple referential inclusion dependencies be represented.} are  represented,
}
\item{
for each intransitive functional dependencies $\{x_1,...x_n\} \morph y$ in model \genericmodel\
either in every instance $E$, $E_{\xntuple}$ is injective and total
or else the functional dependency is represented in the model.
}
\end{enumerate}
\end{definition}

This lemma is a converse to lemma \ref{primarypathrepresentativesidentifying}
\begin{lemma} 
\label{identifyingconverse}
In a well-founded model \genericmodel\ if $Q$ is a identifying set of paths from entity type $a$ to $\veee$
then for every primary key path $p$ from $a$ there is a $q$ in $Q$ such that $p \simeq q$.
\end{lemma}
\begin{proof}
We have modified clause (i) of the definition of well-formed to achieve this.
\end{proof}

\begin{lemma}
\label{mainlemma}
In a well-formed model \genericmodel\ if $\{x_1,...x_n\} \morph y$  is a non-trivial
functional dependency then either $E_{\xntuple}$ is injective and total in every instance $E$ 
or else there is a non-empty  simple path $p:a \rightarrow d$
and a non-identifying path $z:d \morph c$ such that $y \simeq p \circ z$.
\end{lemma}
\begin{proof}
Since \genericmodel\ is well formed then either $E_{\xntuple}$ is injective and total in every instance $E$ and we are done or else the
the functional dependency
$\{x_1,...x_n\} \morph y$   is represented 
by  an entity type $d$ and 
an identifying tuple of simple paths with respect to
$d$, $\qntuple$, such that $\incd{a}{x_1,...x_n}{d}{q_1,...q_n}$ and a simple
path $z=\langle z_1,...z_l \rangle$ such that $z:d\rightarrow c$, for some $l \geq 0$ as here:

\setlength{\arraycolsep}{.2cm}
\begin{center}

$
\begin{array}{cp{2cm}c p{2cm} c}
             &  & \Rnode{b1}{b_1} & &               \\ [0.7cm]
						 &  & \Rnode{b2}{b_2} & &               \\ [0.4cm]
						 &  &     \vdots      & &               \\ [0.2cm]
\Rnode{a}{a} &  &                 & & \Rnode{d}{d}  \\ [-0.2cm]
             &  & \Rnode{bn}{b_n} & &               \\ [0.9cm]
             &  & \Rnode{c}{c}    & &               \\
\end{array}
$
\simplepatha{$x_1$}{a}{b1}
\simplepatha{$x_2$}{a}{b2}
\simplepatha{$x_n$}{a}{bn}
\simplepathb{$y$}{a}{c}
\simplepathb{$q_1$}{d}{b1}
\simplepathb{$q_2$}{d}{b2}
\simplepathb{$q_n$}{d}{bn}
\simplepatha{$z$}{d}{c}
\end{center}
such that
\begin{equation}
\label{fundependency}
E_y = E_{\xntuple} \circ E_{\qntuple}^{-1} \circ E_z
\end{equation}

Because $\incd{a}{x_1,...x_n}{d}{q_1,...q_n}$,  and from
clause (ii) of the definition of well-formedness since \genericmodel\ is well formed, it follows that
there  is a simple path $p:a \rightarrow d$ such
that 
%\foreachi, $p \circ q_i \simeq x_i$ and therefore
in all instances $E$,

\begin{equation}
\label{incdependency}
E_{\xntuple} \circ inv_{E_{\qntuple}} = E_p
\end{equation}
Now we have  that in all instances $E$ that 
\begin{align*}
E_y &= E_{\xntuple} \circ E_{\qntuple}^{-1} \circ E_z  && \text{ (\ref{fundependency}), above,}\\
    &= E_p \circ E_z                                   && \text{by (\ref{incdependency}),}\\
		&= E_{p \circ z}                                   && \text{from defn. of instance }E.\\
\end{align*} 
\vspace{-0.3cm}
From which, by definition, $y\simeq p \circ z$, as required. \\
\end{proof}
Now we give three examples of ER models that fail to be well formed. 
Figures \ref{clubpresidentbeforenormalisation}, \ref{rawdatatablegraph}and  \ref{pickexamplebeforenormalisation}
show examples that fail, respectively, conditions (i), (ii) and (iii) respectively of the definition of well-foundedness. 

The failure of the example in figure \ref{rawdatatablegraph} to be well-formed can be rectified by 
replacing the SeqNo attribute of 
the data cell entity (dc) by an identifying relationship $R_0:dc \morph c$. The resuting model was given in figure \ref{datatablegraph}.

\begin{figure} [h]
\begin{center}
\begin{tabular}{c c}
$
\begin{array}{cp{0.4cm}cp{0.5cm}cp{0.75cm}cp{0.75cm}c}
              &&                &&               &&                &&               \\[0.25cm]
              && \Rnode{cm}{cm} &&               &&                &&               \\[0.25cm]
\Rnode{p}{p}	&&                && \Rnode{m}{m}  &&   \Rnode{c}{c} && \Rnode{v}{v}  \\[0.25cm]
	            &&  
\end{array}
$

\ncarr[5]{p}{cm} 
\alabel{I_0}
\idcomp
\ncarr[-30]{p}{v}
\blabel{yr}
\idcomp
\ncarr[-5]{cm}{m}
\blabel{I_1}
\idcomp
\ncarr[50]{cm}{v}
\alabel{yr1}
\idcomp
\ncarr[25]{m}{v}
\alabel{mNo}
\idcomp
\ncarr{m}{c}
\blabel{M}
\idcomp
\ncarr{c}{v}
\blabel{cId}
\idcomp
& \footnotesize
\begin{tabular}{c p{1.5cm} p{4cm}}
KEY && \\
\hline
p  & president        & Identified by a combination of inclusion relationship ($I_0$) that identifies a
                       president as being a committee members and a year attribute ($yr$). \\
cm & committee member & Identified by an inclusion relationship ($I_1$)that identifies a committee member 
                         as a member and a first year of service attribute ($y1$).\\
m  & member           & Identified by a member relationship ($M$) to a club and a by membership 
                         number attribute ($mNo$). \\
c  & club             & Identified by club identifier attribute ($cId$)
\end{tabular} 
\end{tabular}
\end{center}
\caption{Club president example. 
This example fails clause (i) of the definition of well-formedness because
the set of paths $\set{\tuple{I_0,yr1},\tuple{I_0,I_1,mNo}, \tuple{I_0,I_1,M,cId}, \tuple{yr}}$ is 
an identiofying set of paths wrt $p$ but is not minimum because a club has at most one president a year and sothe subset $\set{\tuple{I_0,yr1}, \tuple{I_0,I_1,M,cId}, \tuple{yr}}$ is jointly monomorphic. 
This problem can be fixed by introducing a clum membership relationship $R: p \morph c$ which is equivalent to
path $\tuple{I_0,I_1,M}$ and by specifying $R$ in place of $I_0$ which is to be combined with $yr$ to identify entitites of type $p$.
}
\label{clubpresidentbeforenormalisation}
\end{figure}
\commentary{Club president example is isomorphic to the nearest shop example!}

\begin{figure} [h]
\begin{tabular}{c p {0.5cm} c}
(a) & &
\begin{tabular}{c c}
$
\begin{array}{cp{0.75cm}cp{0.75cm}c}
   \Rnode{r}{r}     & & \Rnode{t}{t} & & \Rnode{v}{v} \\[1.2cm]     
	 \Rnode{d}{d}   & & \Rnode{c}{c} & &               
\end{array}
$
\ncarr{r}{t} 
\alabel{S_1}
\idcomp
\ncarr{t}{v} 
\alabel{tN}
\idcomp
\ncarr{c}{v} 
\blabel{cN}
\idcomp
\ncarr[-90]{d}{v}
\blabel{SeqNo}
\idcomp
\ncarr{d}{r}
\alabel{S_0}
\idcomp
\ncarr{c}{t}
\blabel{R_1}
\idcomp
\ncarr[50]{r}{v}
\alabel{rN}
\idcomp

& \footnotesize
\begin{tabular}{c p{1.5cm} p{4cm}}
KEY && \\
\hline
t & table & Having identifying attribute tN the name of the table. \\
c & column & Identified by a combination of column number cN and relationship $R_1$ to the table it is a column of.\\
r & row & Identified by its row number $rN$ and its relationship $S_1$ to the table it is a row of.\\
d & data cell & Identified by relationship $S_0$ to the row it is in and its $seqNo$ attribute
representing its ordinal position within data cells of the row. \\
\end{tabular} 
\end{tabular} \\
(b) &   & 
$
\begin{array}{cp{0.5cm}c c c }
   \Rnode{d}{d} &                  &                       & \Rnode{c}{c}  &       \\[.5cm]  
		            & \ \ \ \Rnode{r}{r} &                     &               &       \\[.5cm] 
	              &                  & \Rnode{b1}{b_1} \ \ \ &               &  \Rnode{bn}{b_n}  
\end{array}
$
\ncarr{d}{r} 
\blabel{S_0}[0.25]
\ncarr{r}{b1} 
\blabel{S_1}[0.25]
\ncarr{d}{bn}
\alabel{SeqNo}[0.25]
\ncarr{c}{b1}
\blabel{R_1}[0.25][1]
\idcomp
\ncarr{c}{bn}
\alabel{cN}[0.25]
\idcomp
\end{tabular}
\caption{(a) The model fails condition (ii) for being well-formulated
because there is a referential inclusion dependency of $d[ \tuple{S_0,S_1},\tuple{SeqNo}]$
in $c[\tuple{R_0},\tuple{cN}]$, as indicated in (b), which is not explicitly represented in the model.}
\label{rawdatatablegraph}
\end{figure}

\begin{figure} [h]
\begin{center}
\begin{tabular}{c c}
$
\begin{array}{cp{0.75cm}cp{0.75cm}c}
   \Rnode{p}{p}     & & \Rnode{c}{c} & & \Rnode{v}{v}    
\end{array}
$
\ncarr{p}{c} 
\alabel{R}
\idcomp
\ncarr[25]{c}{v} 
\alabel{wId}
\idcomp
\ncarr[-10]{c}{v} 
\blabel{cSn}
\idcomp
\ncarr[-65]{c}{v}
\blabel{iC}
\ncarr[80]{p}{v}
\alabel{dI}
\idcomp
\ncarr[-100]{p}{v}
\blabel{q}
& \footnotesize
\begin{tabular}{c p{1.5cm} p{4cm}}
KEY && \\
\hline
p & pick & Identified by a combination of relationship $R$ to the crate being picked from
                and the delivery id attribute ($dI$). Also  having a quantity picked 
								attribute ($q$).\\
c & crate & Identified by a combination of warehouse name attribute ($wN$)
              and crate serial number attribute ($cSn$). Also has an item type ($iT$) attribute.
 to the table it is 
\end{tabular} 
\end{tabular}
\end{center}
\caption{If all deliveries are made from items picked from a single warehouse 
then this model fails clause (iii) of the definition of well-formulated because, with tespect to entity type $p$, the path $\tuple{R,wN}$ will be dependent on the path $\tuple{dI}$ but neither is the set 
$\{\tuple{dI}\}$ jointly monic nor has the dependency a representation within the model. A well-formulated and fully factored model for this situation was described previously in 
figure \ref{pickexample}.
}
\label{pickexamplebeforenormalisation}
\end{figure}

\section{Definitions Of Logical and Physical Entity Models}

	
\subsection{Definition of Logical ER Model}

\begin{definition}
A well-formulated ER model is \term{purely-logical}  iff it 
also satisfies:
\begin{enumerate}[(i)]
\item
for all edges $r$ if there is a
a simple path $p$  not including $r$ such that
 $r \simeq p$  then $r$ is identifying and there is an edge $e$ in $p$ which is not identifying,
\item the set of identifying sets I of the model is fully-factored.
\end{enumerate} 
\end{definition}

\noindent
We say that an ER model is a \term{logical ER model} iff it is purely logical.

\subsection{Definition of Physical ER Model}
\begin{definition}
\noindent 
A \term{physical ER model} is a well formulated ER model that also satisfies:
\begin{enumerate}[(i)]
\item
all identifying edges are attributes, \commentary{the set of sets of identifying edges $I$ is closed under composition i.e. $I = \bar{I}$.}

\item
for each relationship $r$ there is there is an inclusion dependency that it represents.
\end{enumerate} 
\end{definition}


\section{First Cut Chen Transformation -- $\chiZero$}

\begin{align}
&\et[\chiZeroM]        && = \et        && \\
&\rel[\chiZeroM]{x}{y} && = \rel{x}{y}  &&\\
&\attr[\chiZeroM]{x}   && = \attr{x}  \cup  \setsuchthat{\tuple{r,k}}{\text{for some }
			                  y \in \et, \ r \in \rel{x}{y} \text{ and } k \in \pk{y}} 
\end{align}

Alternatively, we can define $\attr[\chiZeroM]{x}$ as the union of $\attr{x}$ and foreign keys $\fk{x}$
where we define the latter by:
\begin{equation}
\fk{x} = \setsuchthat{\tuple{r,q_1,...q_n,a}}
                               {r \in \rel{x}{y},
                                  \text{ for some } y \in \et,
																	\text{ and } \tuple{q_1,...q_n,a} \in \pk{y},
																	\text{ for some } n \geq 0
			                   }
\end{equation}

\section{Chi Transform - a Revised Chen Transformation}

This then needs revision\footnote{Check this!} as follows:
\begin{multline}
\fkp{x} = \setsuchthat{\tuple{r,q_1,...q_n,a}}
                      {r \in \rel{x}{y},
                                  \text{ for some } y \in \et,
																	\text{ and } \tuple{q_1,...q_n,a} \in \pk{y},
																	\text{ for some } n \geq 0,                   \right. \\        
											\left.		\text{ and } \tuple{r, q_1,...q_n,a}
																	\text{ is not subsumed by any path }
																	      \tuple{s_1,...s_m} \in \path{x}{v}
											}			                   
\end{multline}

Finally we can define:

\begin{equation}
\fkpp{x} = \fkp{x}/\simeq
\end{equation}
and 

\begin{equation}
\attr[\chiM]{x}  = \attr{x}  \cup  \fkpp{x}
\end{equation}


\begin{lemma}
\label{fdcarrythroughlemma}
Functional depedencies in \genericmodel\ carries through to functional depdencies in $\genericphysical$ \commentary{Expand}
\end{lemma}
\begin{proof}

\end{proof}

\section{Boyce-Codd Normal Form}
\noindent One measure of the goodness of a physical model is whether it satisfies the well-formedness condition know as Boyce Codd Normal Form.
Written in the terminology we are using here it can be defined as follows:
\begin{definition} % BCNF
A physical ER model is in Boyce Codd Normal Form (BCNF) \commentary{See Zaniolo definition 2.} iff
for all entity types $a$, for all attributes $x_1,...x_n$ and $y$ of $a$, for $n \geq 1$, 
for which  there is a non-trivial functional dependency \sfd{x_1,...x_n}{y}, 
in all instances $E$  of $\genericmodel$, the function $E_{<x_1,...x_n>}$ is injective and total.  
\end{definition}

\begin{definition} % TNF
A physical ER model is in Third Normal Form (TNF)  iff
for all entity types $a$, for all attributes $x_1,...x_n$ and $y$ of $a$, for $n \geq 1$, 
for which  there is a non-trivial functional dependency \sfd{x_1,...x_n}{y}, 
in all instances $E$  of $\genericmodel$, either the function $E_{<x_1,...x_n>}$ is injective and total
or else $y$ is all identifying.\commentary{new - justify this}.  
\end{definition}

\noindent The next lemma simplifies the requirement for showing BCNF to consideration of non-trivial
intransitive functional dependencies:
\begin{lemma}
\label{BCNFsublemma}
A model $\genericmodel$ is in BCNF iff
for all entity types $a$, for all attributes $x_1,...x_n$ and $y$ of $a$, for $n \geq 1$, 
for which there is an non trivial intransitive functional dependency \sfd{x_1,...x_n}{y},
in all instances $E$, $E_{<x_1,...x_n>}$ is injective and total. 
\end{lemma}
\begin{proof}Use lemma \ref{transitiveinjectivelemma}.
\end{proof}

\noindent Now for the main theorem:\\
\begin{theorem}
\noindent If an ER model $\genericmodel$ is well-formulated and logical then the 
transformed model $\logtophys(\genericmodel)$  is in Third Normal Form. If in $\genericmodel$
there are no identifying edges $r$ such that $r \simeq p$ for some path $p$ of length greater than $1$
then $\logtophys(\genericmodel)$ is in Boyce-Codd Normal form. \commentary{Needs modifying to TNF}.
\end{theorem}
\begin{proof}
By lemma \ref{BCNFsublemma} it suffices to show that if 
$\sfd{\phys{x}_1,...\phys{x}_n}{\phys{y}}$ is a non-trivial intransitive functional dependency of model $\genericphysical$
where $\phys{x}_1,...\phys{x}_n,\phys{y}$ are attributes of the entity type $a$ of model $\genericphysical$ 
then  in all instances
$E$ of $\genericphysical$, $E_{<\phys{x}_1,...\phys{x}_n>}$ is injective and total. \\


\noindent Assume, then, such a functional depedency $\sfd{\phys{x}_1,...\phys{x}_n}{\phys{y}}$ in  $\genericphysical$. 
By lemma \ref{fdcarrythroughlemma} it follows that in the model $\genericmodel$, for each $i$, $1 \leq i \leq n$, 
for some $m_i$, $m_i \geq 1$, we have a 
path of length $m_i$ which we denote $x_i = \langle x_{i,1},...x_{i,m_i} \rangle$  and for some $m$, $m \geq 1$ we have a path 
of length $m$ which we denote 
$y=\langle y_1,..y_m \rangle$ as shown here: 
\setlength{\arraycolsep}{.2cm}
\begin{center}
$
\begin{array}{cp{2cm}cc}
             & &         & \Rnode{b1}{v} \\ [0.5cm]
						 & &         & \Rnode{b2}{v} \\ [0.6cm]
						 & & \vdots  &                 \\ [0.2cm]
\Rnode{a}{a} & &         & \Rnode{bn}{v} \\ [1.0cm]
             & &         & \Rnode{c}{v}   \\
\end{array}
$
\simplepatha{$x_1$}{a}{b1}
\simplepatha{$x_2$}{a}{b2}
\simplepatha{$x_n$}{a}{bn}
\simplepathb{$y$}{a}{c}
\end{center}
and that \sfd{x_1,...x_n}{y} in \genericmodel.

From the assumption that the model $\genericmodel$ is well-formulated and from condition (iii) 
of the definition of well-formulated, either 
$E_{\langle x_1,...x_n \rangle}$ is injective and total in every instance $E$ of $\genericmodel$, in which case 
$\logtophys(E)_{\langle \phys{x}_1,...\phys{x}_n \rangle}$ is injective and total in every instance $E$ of $\genericmodel$ and the proof is completed, or else
the functional dependency  \sfd{x_1,...x_n}{y} is represented in the model $\genericmodel$. 


From the definition of a functional dependency being represented it follows that
there is an entity type $b$ in $\genericmodel$  and an identifying family of simple paths $q_1,...q_n$, 
$q_i: b \rightarrow v$ and a 
path $z: b \rightarrow v$, as shown here: 
such that


\setlength{\arraycolsep}{.2cm}
\begin{center}
$
\begin{array}{cp{2cm}ccp{2cm}c}
             & &         & \Rnode{b1}{v} &&              \\ [0.5cm]
						 & &         & \Rnode{b2}{v} &&              \\ [0.6cm]
						 & &         &    \vdots     &&              \\ [0.2cm]
\Rnode{a}{a} & &         & \Rnode{bn}{v} && \Rnode{b}{b} \\ [1.0cm]
             & &         & \Rnode{c}{v}  &&              \\
\end{array}
$
\simplepatha{$x_1$}{a}{b1}
\simplepatha{$x_2$}{a}{b2}
\simplepatha{$x_n$}{a}{bn}
\simplepathb{$y$}{a}{c}
\simplepathb{$q_1$}{b}{b1}
\simplepathb{$q_2$}{b}{b2}
\simplepathb{$q_n$}{b}{bn}
\simplepatha{$z$}{b}{c}
\end{center}
such that
\begin{equation}
\label{inclusiondependency}
\incd{a}{x_1,...x_n}{d}{q_1,...q_n}
\end{equation}
and such that in every instance $E$ of $\genericmodel$:
%\newcommand{\ineveryinstance}{\forall E \in inst_\genericmodel ,  \hspace{0.25cm} }
\begin{equation}
\label{representationByIdentifyingRelationships}
E_{\langle x_1,...x_n \rangle}\circ inv_{E_{\qntuple}} \circ E_{z} = E_{\langle y_1,..y_m \rangle} 
\end{equation}

Note that $z$ cannot be equivalent to a primary key attribute for if it were then by lemma \ref{identifyingconverse}
it would be equivalent to $q_i$,
for some $i$, $1 \leq i \leq n$ from which it would follow that $E_y=E_{x_i}$ in each instance $E$ and therefore, from the definitions, 
we would have that $y \simeq x_i$ and therefore that $\phys{y}=\phys{x_i}$ contradicting the assumption that
the fucntional dependency $\sfd{\phys{x}_1,...\phys{x}_n}{\phys{y}}$ is non-trivial.


Since there is an inclusion dependency (\ref{inclusiondependency}) in $\genericmodel$ and from the assumption that  model
$\genericmodel$ is well-formulated it follows
 from condition (ii) of the definition of well-formulated  that there exists
a path $\langle p_1,...p_k \rangle:a \rightarrow b$, $k \geq 0$, such that:
\begin{equation}
\label{simpleRepresentationOfFirstPart}
\langle E_{x_1},...E_{x_n} \rangle \circ inv_{E_{\qntuple}} = E_{\langle p_1,...p_k \rangle}
\end{equation}
\noindent Either $k=0$ and $\qntuple = \langle x_1,...x_n \rangle$ in which case $E_{\langle x_1,...x_n \rangle}$ is
injective and total in every instance $E$ of $\genericmodel$ and thus $\logtophys(E)_{\langle \phys{x}_1,...\phys{x}_n \rangle}$ is
injective and total in every instance $\logtophys(E)$ of $\genericphysical$ and the proof is complete 
\noindent or else $k \geq 1$ and it follows from (\ref{representationByIdentifyingRelationships}) and (\ref{simpleRepresentationOfFirstPart}) that:
\begin{equation} 
\label{simpleRepresentation}
 E_{\langle p_1,...p_k \rangle} \circ E_{\langle z_1,...z_l \rangle} = E_{\langle y_1,..y_m \rangle} 
\end{equation}


We will show that this leads to a contradiction and so complete the proof. 

If $m >1$ then
 from  (\ref{simpleRepresentation}),
from clause (i) of the definition of subsumes and from the fact demonstrated above that $z$ is not equivalent to a 
primary key attribute
it follows that $p_1,...p_k,z_1,...z_l$ subsume $\langle y_1,..y_m \rangle$, 
which implies that $\langle y_1,..y_m \rangle$ is excluded from $\fkp{a}$ and thus that 
 $\phys{y}=\left[\langle y_1,..y_m \rangle\right]$ is not an attribute of $\genericphysical$ contrary to our 
initial assumption. 

We must conclude that $m=1$.
In this case we have $y_1$, an attribute of $a$ in $\genericmodel$, and from (\ref{simpleRepresentation})  we have in all instances $E$ of $\genericmodel$:
\begin{equation}
E_{y_1}=E_{\langle p_1,...p_k \rangle} \circ E_{\langle z_1,...z_l \rangle}
\end{equation}
\noindent which is to say that in all instances $E$ of $\genericmodel$:
\begin{equation}
E_{y_1}=E_{\langle p_1,...p_k ,z_1,...z_l \rangle}
\end{equation}
\noindent
We have shown, therefore, that $y_1$ is an outgoing edge of $a$ in $\genericmodel$ 
which is equivalent to a simple path of $\genericmodel$ of length $\geq 2$.
Therefore since $m$ is logical,  $y_1$ is identifying as required to establishing TNF
or if we have assumed no such $y_1$ the assumption is contradicted and we establish BCNF.
This completes the proof.
\end{proof}
\newpage
\section{Discussion}

\subsection{Equ-Join Definition of Inclusion Dependency}
\begin{definition}
\noindent An \term{equi-join condition} between two entity types $a$ and $b$ is defined to be a sequence of pairs of attributes of 
 $a$ respectively $b$ i.e it is for some $n$, $n \geq 1$ a sequence of $n$ pairings of attributes of $a$, respectively, $b$, i.e. a function $\sigma: N_n \rightarrow \attr{a} \times \attr{b}$. \\
\end{definition}

\noindent If $\sigma$ is a equi-join condition between two entity types $a$ and $b$ then we will denote the i'th pairing of attributes as $\sigma_{i,1},\sigma_{i,2}$. 
Thus we have that  $\sigma_{i,1} \in \attr{a}$ and $\sigma_{i,2} \in \attr{b}$. \\

\noindent If $\sigma$ is a equi-join condition within a schema $s$\commentary{ model $M$?} and if $E$ is an instance of $s$ then denote by $E_\sigma$
the many-valued function from $E_a$ to $E_b$
defined by $\sigma(e) = \{ e' \in E_b : \forall i \in N_n, \sigma_{i,1}(e)=\sigma_{i,2}(e') \}$. \\

\begin{definition}
An equi-join condition  $\sigma$ between two entity types $a$ and $b$ is defined to be an 
\term{inclusion dependency}
iff the set $E_\sigma(e)$ is non-empty, for all instances E of s\commentary{ wherefore $s$?} and for all $e \in E_a$. \\
\end{definition}

\noindent
By the \term{domain} of a join condition $\sigma$ in an instance $E$ we shall mean the  set $\{ e \in E_a \| \forall i, 1 \leq i \leq n, \sigma_{i,1}(e) \mbox{is defined} \}$.\marginpar{\tiny typesetting error has been corrected} \\


\begin{definition}
An inclusion dependency $\sigma$ between two entity types $a$ and $b$ is 
\term{referential}\footnote{Also called a referential constraint or a foreign key constraint. Oracle Database Concepts Documentation: \textit{If any column of a composite foreign key is null, then the non-null portions of the key do not have to match any corresponding portion of a parent key.}  } 
iff the set $E_\sigma(e)$ is a singleton set, for all instances E and for all $e$ in the domain of  $\sigma$ . 
\end{definition}

\subsection{Query path expressions}
\noindent Without change to the underlying concept then we can say that each ER schema comes equipped with a multi-edge $I_a$ for every entity type a such that if 
the outgoing identifying edges of $a$ are $k_i: a \rightarrow a_i$, for $1 \leq i \leq n$  then the multi-edge has source nodes $\langle a_1,...a_n\rangle$ and destination node $a$.  

\noindent We extend the earlier  definition of simple path to take account of navigation along the multi-edges. To do so we define the set of navigation paths recursively:

\begin{enumerate} [(i)]
\item{ Each edge $f: a \rightarrow b$ is a navigation path.
}
\item{ The empty sequence  $\langle \rangle : a \rightarrow a$ is a navigation path for every entity type $a$.
}
\item{ $\langle p,f \rangle : a \rightarrow c$ is a navigation path  if $p$ is a navigation path $p: a \rightarrow b$ and $f $is an edge $p: b \rightarrow c$
}
\item{ $\langle p_1,...p_n,I_b\rangle : a \rightarrow b$ is a navigation path for all entity types $b$ such that $I_b: \langle b_1,...b_n\rangle$ and where
for each $i$, $1 \leq i \leq n$, $p_i$ is a path, $p_i: a \rightarrow b_i$.   
}
\end{enumerate}

\noindent For any database instance $E$ we can  extend  the definition of
$E_f$, for edges $f$,  so that to every path $p$, $p: a \rightarrow b$,  we have defined a function $E_p: E_a \rightarrow E_b$. From the initial definition of $E_f$ that applies to 
edges the definition proceeds recursively as follows: 
\begin{enumerate} [(i)]
\item{  For each entity type $a$, $E_{\langle \rangle}: E_a \rightarrow E_a$ is defined to be the identity function.
}

\item{   if $p$ is a navigation path $p: a \rightarrow b$ and $f$ is an edge $p: b \rightarrow c$ then $E_{\langle p,f \rangle}$ is 
is defined to be the functional composition $E_p \circ E_f$.
}

\item{ for all entity types $b$ such that $I_b: \langle b_1,...b_n\rangle \rightarrow b$ and where
for each $i$, $1 \leq i \leq n$, $p_i$ is a path, $p_i: a \rightarrow b_i$, $E_{\langle p_1,...p_n,I_b\rangle}$ is defined to be 
$\langle E_{p1},...E_{p_n} \rangle \circ inv_{E_{\i{b}}}$.
}
\end{enumerate}
\noindent If $p$ is a query path expression within an ER model $\genericmodel$ then say that the path is \term{explicitly represented} wrt the model iff it is equivalent to a simple path. \\

\subsection{Transitivity}
\begin{figure}
\begin{tabular}{c l c l}
\input{pickExampleTransitiveDependencyRHS}
\\
\\
DEPENDS ON  \\
\\
$
\begin{array}{cp{0.5cm}cp{0.5cm}c}
               &  &                  & &     \Rnode{w}{w}   \\[-0.35cm]
               &  &   \Rnode{c1}{c}  & &                    \\[-0.05cm]
\Rnode{p}{p}   &  &                  & &                    \\[-0.05cm]
               &  &   \Rnode{c2}{c}  & &                    \\[-0.25cm]
               &  &                  & &     \Rnode{v}{v}
\end{array}
$
\ncarr[5]{p}{c1}
\alabel{R_0}
\idcomp 
\ncarr[-5]{p}{c2}
\blabel{R_0}
\idcomp 
\ncarr[5]{c1}{w}
\alabel{R_1}
\idcomp
\ncarr[-5]{c2}{v} 
\blabel{cSn}
\idcomp & because & 
$
\begin{array}{cp{0.5cm}c}
               & &     \Rnode{w}{w}   \\[-0.15cm]
\Rnode{c}{c}  & &                    \\[-0.05cm]
               &  &    \Rnode{v}{v}
\end{array}
$
\ncarr[5]{c}{w}
\alabel{R_1}
\idcomp
\ncarr[-5]{c}{v} 
\blabel{cSn}
\idcomp
 & is an identifying family \\
\\
EQUIVALENT TO  \\
\\
\input{pickExampleTransitiveDependencyIntermediate}
 & because & $\tuple{R_0,R_1} \simeq \tuple{S_0,S_1}$ \\
\\
DEPENDS ON  \\
\\
$
\begin{array}{cp{0.5cm}cp{0.5cm}c}
               &  &   \Rnode{d}{d}  & &                    \\[-0.05cm]
\Rnode{p}{p}   &  &                  & &                    \\[-0.05cm]
               &  &   \Rnode{c2}{c}  & &                    \\[-0.25cm]
               &  &                  & &     \Rnode{v}{v}
\end{array}
$
\ncarr[5]{p}{d}
\alabel{S_0}
\idcomp 
\ncarr[-5]{p}{c2}
\blabel{R_0}
\idcomp 
\ncarr[-5]{c2}{v} 
\blabel{cSn}
\idcomp & by weakening & \\
\\
DEPENDS ON  \\
\\
\input{pickExampleTransitiveDependencyLHS} & because & 
$
\begin{array}{cp{0.5cm}c}
               & &     \Rnode{v1}{v}   \\[-0.15cm]
\Rnode{d}{d}  & &                    \\[-0.05cm]
               &  &    \Rnode{v2}{v}
\end{array}
$
\ncarr[5]{d}{v1}
\alabel{oId}
\idcomp
\ncarr[-5]{d}{v2} 
\blabel{dSn}
\idcomp
 & is an identifying family. \\
\end{tabular}

\caption{Illustration of transitive dependence and Representation- In this model the path $\tuple{R_0,R_1}$ is equivalent to path $\tuple{S_0,S_1}$. The path $\tuple{R_0}$ depends transitively on the paths
$\tuple{S_0,oId}$, $\tuple{S_0,dSn}$ and $\tuple{R_0,cSn}$. The dependence is transitive
because there is a path $P=\tuple{S_0,S_1}$ and $P$ depends on $\tuple{S_0,oId}$ and $\tuple{S_0,cSn}$
and $\tuple{R_0,sC}$ depends on $P$ and $\tuple{R_0,iN}$. }
\label{transitiverepresenationillustration}
\end{figure}


\begin{figure}
The dependency of 
\input{pickExampleTransitiveDependencyRHS} on 
\input{pickExampleTransitiveDependencyLHS} is represented by the following diagram:
\input{pickExampleTransitiveDependencyRepresentationDiagram}
\vspace{1.0cm}
\caption{Representation of dependencies}
\end{figure}
\iffalse
\subsection*{NOT NEEDED}
\noindent \textbf{Notation}
\commentary{ Try and get rid of this in favour of fds being `elementary'.}
If $X_1,...X_n$ are sets and if $J=\{i_1,...i_j\} \subseteq \{1,...n\}$ then denote by $P_J$ the projection function :
$$
P_J : X_1 \times X_2 \times ...X_n \rightarrow X_{i_1} \times X_{i_2} \times ... X_{i_j}
$$
\noindent i.e. the function given by:
$$
P_J(\langle x_1,...x_n \rangle ) = \langle x_{i_1},...x_{i_j} \rangle.
$$

\begin{definition}
\commentary{ Try and get rid of this in favour of fds being `elementary'.}
If $\genericmodel$ is an entity model, if $b_1,...b_n$ and $c$ are entity types of model $\genericmodel$  and if $f_E$ is a family of functions 
such that in every instance $E$ of $\genericmodel$:
$$
f_E : E_{b_1} \times ... \times E_{b_n} \rightarrow E_c
$$
then 
\begin {itemize}
\item{the family of functions $f_E$ is said to be \term{reducible} to a family of functions:
$$
g_E : E_{b_{i_1}} \times ... \times E_{b_{i_j}} \rightarrow E_c
$$
for some $J=\{i_1,...i_j\} \subseteq \{1,...n\}$, iff in all instances E:
$$
f_E = P_J \circ g_E
$$
}
\item{
the family of functions $f_E$ is said to be \term{irreducible} iff there is no proper subset
 $J=\{i_1,...i_j\} \subset \{1,...n\}$, and no family of functions 
$g_E : E_{b_{i_1}},...E_{b_{i_j}} \rightarrow E_c$ such that $f_E$ is reducible to $g_E$.
}
\end{itemize}
\end{definition}

\begin{remark}
For any entity model $\genericmodel$ and for any type $b$ of $\genericmodel$ the family of identity functions on 
entities of type $b$ :
$$
id_{E_b} : E_b \rightarrow E_b
$$
is represented because we can choose both $q: b \rightarrow b$ and and
$z: b \rightarrow b$ to be the empty path $\langle \rangle$; then we have:
\begin{align*}
inv_{E_{\qntuple}}\circ E_{\langle z_1,...z_l \rangle} & = inv_{E_{\langle \rangle}} \circ E_{\langle \rangle} \\
                                                                        & = id_{E_b}^{-1} \circ id_{E_b} \\
                                                                        & = id_{E_b} 
\end{align*}
as required.
\end{remark}
\begin{remark}
For any entity model $\genericmodel$, for any $n \geq 1$, for any tuple of types $b_1,...b_n$ and for any $i$, $1 \leq i \leq n$, if in any instance
$E$ of $\genericmodel$, ${p_i}_{_E}$ is the i'th projection function:
$$
{p_i}_{_E}: E_{b_1} \times ... \times E_{b_n} \rightarrow E_{b_i}
$$
then the family of functions ${p_i}_{_E}$ are represented in model $\genericmodel$. This is because this family of functions is reducible to the family of identify functions on $E_{b_i}$ and this family is represented as previously remarked.
\end{remark}
\fi
\subsection*{Inference of Identifying Relationships}
From the primary key definitions in a model $\genericmodel$ the identifying attributes and relationships can be inferred as follows:

\begin{definition}
A set of simple paths $\set{p_1,...p_n}$ is said to be an 
\term{identifying set with respect to an entity type $x$} iff for every primary key $k$
 there is an $i$, $1 \leq i \leq n$ such that in every 
instance $E$, the function $E_k$ factors through $E_{p_i}$. 
\end{definition}
We say that a relationship is \textit{identifying} if it is part of an identifying set. 

Note that with these definitions it follows that the set of all identifying relationships exiting an entity type $x$ is an identifying set.

\subsection*{Unused as at 17 July 2019}

\begin{lemma}
In a model \genericmodel\ if $a$ is an entity type and if $(I_a \simeq J_0 \cup \set{f})\textvisiblespace_f G$,
for some $f: a \morph b$ and some $G \in \bar{I}_b$ then 
$I_a$ is a mono-source iff $J \cup \set{f}$ is a mono-source.
\end{lemma}
\begin{proof}
\end{proof} 


\begin{lemma}
\label{primarykeypathsjointlymonomorphic}
If If $a$ is an entity type in an entity model \genericmodel\ then the set of all primary key paths 
of $a$ is jointly monomorphic.
\end{lemma}
\begin{proof}
Because all sets of identifying edges are jointly monomorphic and because jointly injective sets
yield jointly injective sets when composed by lemma \ref{identifyingsetcomposition}. \commentary{Do a better job of this proof.}
\end{proof}

\begin{definition}
If $a$ is an entity type in an entity model \genericmodel\ then a set $Q$ of paths 
leaving $a$ is said to be \term{an identifying set of paths} with respect 
to an entity type $a$ iff for every primary key path $p:a \morph v$, there exists 
a path $q \in Q$ and a path $q'$ in \genericmodel\ such that $q \circ q' \simeq p$.
\end{definition}

\begin{lemma}
If $Q$ is an identifying set of paths in a model \genericmodel\ then it is jointly monomorphic.
\end{lemma}
\begin{proof}
Use lemma \ref{primarykeypathsjointlymonomorphic} and lemma \ref{jointlyinjectivededuction} as follows. 
\end{proof}

\begin{lemma} 
\label{primarypathrepresentativesidentifying}
In a model \genericmodel\ if $Q$ a set of primary key paths from entity type $a$ 
and if every primary key path from $a$ is equivalent to a path in $Q$ then
$Q$ is an identifying set of paths. 
\end{lemma}
\begin{proof}
here
\end{proof}

\begin{lemma}
\label{jointlyinjectivededuction}
If $A$ is a set and if  $K$ is a jointly injective set of functions with domain $A$, if $I$ is
some other set of functions with domain $A$ and having the property that for all $k \in K$,
there exists $i \in  I$ and a function $j$ such that $i \circ j = k$ then $I$ is jointly injective.
\end{lemma}
\begin{proof}
Suppose $x,y \in A$ and for all $i \in I$, $i(x)=i(y)$. For all $k \in K$ we have, for some $j$, that
$k(x) = j(i(x)) = j(i(y)) = k(y)$; therefore because $K$ is jointly injective we have that $x=y$.
Therefore $I$ is jointly injective. 
\end{proof}

\end{document}
