 \documentclass[10pt,a4paper]{article}

\newcommand{\sharedmacros}{../../SharedMacros}
\input{\sharedmacros/ccategories.macros}
\input{\sharedmacros/ermacros}
\input{\sharedmacros/erdiagram}
\input{\sharedmacros/theorems.macros}
\input{\sharedmacros/general.macros}
\usepackage{mathptmx}  % This changes font to roman
\usepackage{anyfontsize}
\usepackage{mathtools}  % why have we got this?
\usepackage{alltt}    
\usepackage{mnsymbol} %used for rightpitchfork
\usepackage{cmll}
\usepackage{ulem}
\renewcommand{\ttdefault}{txtt}
\usepackage[left=1.5cm, right=4cm, marginparwidth=3cm, top=2cm, bottom=2.0cm]{geometry}
\usepackage{framed}
\usepackage[font=small]{caption}
\setlength{\captionmargin}{2cm}
\theoremstyle{remark}
\newtheorem*{lemma*}{Lemma}

\usepackage{arydshln} % vertical dashed lines between columns of an array


\input{../macros/othermacros.tex}

\renewcommand{\term}[1]{\textit{#1}}

%ENDCOPY

\begin{document}
\title{Directed Graph Examples}

% abstract here for ams

\author{John Cartmell}

\date{}

%\maketitle

\newcommand{\seenudgeup}[1]{\rule{0.1cm}{#1}}
\newcommand{\seenudgedown}[1]{\rule[-#1]{0.1cm}{0.1cm}}
\newcommand{\nudgeup}[1]{\rule{0cm}{#1}}
\newcommand{\nudgedown}[1]{\rule[-#1]{0cm}{0.1cm}}

\newcommand{\stringtype}{text}
\newcommand{\numbertype}{number}


% Example of above: \newcommand{\fgsourcediag}{\binarysourcediagram{a}{b}{c}{f}{g}}

\newcommand{\dgsrcedge}
{
\setlength{\arroffsetA}{3pt}
\setlength{\arroffsetB}{3pt}
\ncarr[5]{edge}{node} 
\arreset  
}
\newcommand{\structuraldgsrcedge}
{
\setlength{\saroffsetA}{3pt}
\setlength{\saroffsetB}{3pt}
\ncsar[5]{edge}{node} 
\sarreset 
}
\newcommand{\dgtargetedge}
{
\setlength{\arroffsetA}{-3pt}
\setlength{\arroffsetB}{-3pt}
\ncarr[-5]{edge}{node} 
\arreset   
}
\newcommand{\dgbasic}
{
\begin{array}{c}
\Rnode{node}{node}  \\[2cm]
\Rnode{edge}{edge}       
\end{array}
\begin{arrows}
\dgsrcedge
\alabel{src}
\dgtargetedge
\blabel{trg}
\end{arrows}    
}

% dgbasiclabelled{labeltype}
\newcommand{\dgbasiclabelled}[1]
{
\begin{array}{cp{0.75cm}c}
%rule [raise-height]{width}{height}
\dgbasic   &&  \Rnode{labeltypelhs}{\rule[0cm]{0cm}{0.3cm}}\Rnode{labeltype}{#1} 
\end{array}
\begin{arrows}
\ncarr{node}{labeltypelhs}
\alabel{label}
\ncarr{edge}{labeltypelhs}
\blabel{label}
\end{arrows}       
}

\newcommand{\setoflabelleddgs}
{
\begin{array}{cp{1.0cm} : p{0.5cm}c}
\setofdg   &&&
\begin{array}{l}
\Rnode{text}{}\stringtype \\[1cm]
\Rnode{number}{}\numbertype 
\end{array}
\end{array}
\begin{arrows}
\ncarr{dg}{text}
\alabel{name}[0.3]
\ncarr{node}{number}
\alabel{label}[0.3]
\ncarr{edge}{number}
\blabel{label}[0.3]   
\end{arrows}
}


\newcommand{\structuraldgbasic}
{
\begin{array}{c}
\Rnode{node}{node}  \\[2cm]
\Rnode{edge}{edge}       
\end{array}
\begin{arrows}
\structuraldgsrcedge
\alabel{src}
\dgtargetedge
\blabel{trg}
\end{arrows}    
}

\newcommand{\nodepartof}
{
\ncarr{node}{dg}     
}
\newcommand{\structuralnodepartof}
{
\ncsar{node}{dg}     
}
\newcommand{\setofdg}
{
\begin{array}{c}
\rnode{dg}{dg} \\[2cm]
\dgbasic
\begin{arrows}
\nodepartof
\end{arrows}
\end{array}
}




\newcommand{\structuralsetofdg}
{
\begin{array}{c}
\rnode{dg}{dg} \\[2cm]
\structuraldgbasic
\begin{arrows}
\structuralnodepartof
\end{arrows}
\end{array}
}

\section{Theories and Logical Data Specifications}

\section*{Theory of a directed graph}
\begin{displaymath}
\dgbasic
\end{displaymath}

An instance of this theory i.e. a directed graph can be defined 
as a mapping of the directed graph into the category
$\Fin$ of finite sets or equivalently as a functor $D: \catcw \morph \Fin$
where \catcw is the catgeory generated from the directed graph consisdered as a sketth
of a category.

I shall avoid use of the term `model' at this point.

\section*{Theory of a set of directed graphs}
\begin{displaymath}
\setofdg
\end{displaymath}

\section*{Theory of a labelled directed graph}

\begin{displaymath}
\dgbasiclabelled{l}
\end{displaymath}


\section*{Theory of a numerically labelled directed graph}

\begin{displaymath}
\dgbasiclabelled{number}
\end{displaymath}

The object $number$ has a fixed interpretation in \Fin, as $N_{2^{32}}$, say.
Johnson et al. arrange for this to case by having objects like $number$, $boolean$, $float$
and $string$  defined as coproducts of multiple copies of a terminal object $1$. 
In the case of the number type the injections form $1$ to $number$ will represent
the elements $0,1,2,..$ upto some defined limit such as $2^{32}$. 

\section*{Theory of a numerically labelled directed graph -- detailed}

\begin{displaymath}
\begin{array} {c}
\begin{array} {p{1.5cm} c}
     & \Rnode{abs}{\ \ 1\ \ }  
\end{array} \\[1.0cm]
\dgbasiclabelled{number}  
\end{array}
\begin{arrows}
%\setlength{\arroffsetA}{3pt}
\setlength{\arroffsetA}{-6pt}
\setlength{\arroffsetB}{-12pt}
\ncarr{abs}{labeltype}
\alabel{0}
\setlength{\arroffsetA}{3pt}
\setlength{\arroffsetB}{0pt}
\ncarr{abs}{labeltype}
\alabel{1}
\setlength{\arroffsetA}{9pt}
\setlength{\arroffsetB}{12pt}
\ncarr{abs}{labeltype}
\alabel{2 \hdots}
\end{arrows}
\end{displaymath}

In the category \catcw generated by the sketch the object $number$ is the coproduct
of multiple copies of the terminal object $1$ with injections $0,1,2,...$.
Most often this is a finite coproduct. Upto $2^32$, say.
Instances are functors from \catcw to $\Fin$ that preserve finite coproducts.

\section*{Theory of a set of named numerically labelled directed graphs}

\begin{displaymath}
\setoflabelleddgs
\end{displaymath}

\section*{Theory of a labelled directed graph with uniquenes of labels }
\subsection*{Edge labels unique across the whole graph}
\begin{displaymath}
\begin{array}{cp{0.75cm}c}
\dgbasic   &&  \Rnode{l}{l} 
\end{array}
\begin{arrows}
\ncarr{node}{l}
\alabel{label}
\idcomp
\ncarr{edge}{l}
\blabel{label}
\idcomp
\end{arrows}
\end{displaymath}
\subsection*{Edge labels unique within edges leaving a node (eg a state transition diagram)}

Specify  that this source \binarysourcediagram{edge}{node}{l}{src}{label} is  a monosource. A 
rough and ready notation for this is to bar arrows that participate in the mono source as so:

\begin{displaymath}
\begin{array}{cp{0.75cm}c}
\dgbasic   &&  \Rnode{l}{l} 
\end{array}
\begin{arrows}
\ncarr{node}{l}
\alabel{label}
\idcomp
\ncarr{edge}{l}
\blabel{label}
\idcomp
\dgsrcedge  % redrawn so that I can bar it with \idcomp
\idcomp
\end{arrows}
\end{displaymath}

If two different monosources to be specfied at the same node then can still be shown 
on a single diagram if the bars are subscripted i.e. labelled.


\subsection*{Theory of a set of uniquely numbered text labelled directed graphs with edge labels unique within edges leaving a node}

\begin{displaymath}
\setoflabelleddgs
%
\begin{arrows}
%redraw arrows and bar using \idcomp
\ncarr{dg}{text}
\idcomp
\ncarr{node}{number}
\idcomp
\ncarr{edge}{number}
\idcomp
\dgsrcedge  % redrawn so that I can bar it with \idcomp
\idcomp
\nodepartof  % repeat so thatI can bar with \idcomp
\idcomp
\end{arrows}
\end{displaymath}

In this example nodes to the right of the dashed line are required to have a fixed interpretation in $\Set$.

The way that Johnson et al. arrange for this is by defining these types to be codproducts of morphisms 
from the terminal object and by defining instances to be coproduct preserving. 
This is pretty neat because cardinality concerns aside (of which more later) 
each functor $Hom_\catc(x,\_)$ functor is then an instance where \catcw is the category generated by the sketch and $x$ is any object of \catc.

This is the most important charcateristic of a theory that can be considered a data specification. 
Certain types have fixed interpretations. These are sometimes referred to as scalar types or primitive types.
Sometimes called domains. Johnson et al refer to them as attributes.
These are of two kinds
\begin{enumerate}
\item the types which are built in to programming languages and data specification languages:  $float$, $int-32$, $int-64$, $char$, $varchar$, $string$ and so on.
\item types that are user-defined as enumerations of values. Color might be defined as 
consisting of the values $red$, $green$ and $blue$. 
\end{enumerate}

The approach of Johnson at al. treats these two kinds of types the same way for theory purposes. 

What is important to me at least is that there are no morphisms that leave the right hand side of this diagram and enter the left hand side.


\section{Universals and Particulars}
The generic style of data specification system
that we describe here involves definition of types of particulars in terms of their relationships with other types,
of which there are two kinds, those, such as represent numbers, character strings, booleans and so on, all of
whose instances are universals and, the definienda, those types all of whose instances are particulars. The binary many-one data relationships  are functional in character and can be though of as the edges of a graph whose nodes comprise all types - both the types of particulars and the types of universals. 


The terminology used is diverse. For edges that cross the divide from left to right in this diagram 
in entity relationship modelling 
are said to be attributes whereas in relational data modelling they are presented as columns of tables; types all of whose instances are universals  are said to be \textit{attribute types} in entity relational 
modelling, though  these are called \textit{attributes} by Johnstone et al.; in the initial work by  Chen such types were called \textit{value sets}; they are said to be \textit{domains} in relational data modelling theory. 

\newcommand{\Veee}{V}
\newcommand{\veee}{v}
Types of particulars are said to be 
types of entities or \textit{entity types} in modern entity relational modelling
or sometimes, confusingly, just \textit{entities}  and 
are modelled as \textit{relational tables} in relational data modelling. 

\newcommand{\universals}{\textbf{Unls}}


From now on we  assume a category that represents types all of whose instances are universals. 
We shall denote this category by $\universals$. 
We require that $\universals$ is a category having a terminal object $1$ and such that all of its objects 
are coproducts of the object $1$. 

If \catcw is the category generated by a sketch considered as a data specification relative to 
the category $\universals$  then 
\begin{itemize}
\item \catcw has $\universals$ as a full subcategory,
\item \catcw does not have morphisms with domain in the $\universals$ subcategory 
and codomain outside of $\universals$.
\end{itemize}

\begin{aside}
\newcommand{\puarrowcat}{\textbf{pu}}

I be using the terms \term{universal} and \term{particular} as they are used in philosophy.

By a \textit{universal instance} of an object $x$ in a category with terminal object $1$ we mean a morphism from the terminal object $1$ to the object $x$.

Let \puarrowcat\  be the arrow category with two objects and a single morphism between them.
Denote the domain object $p$ and  the codomain object $u$.

A \term{pu-category} consists of a category \catcw with terminal object $1$ 
along with  a functor $\kappa: \catcw \morph \puarrowcat$ 
such that for each object $x \in \kappa^{-1}(u)$, $x$ is a coproduct of its universal instances.

From what we have said it follows that the terminal object $1$ of \catcw is a u-object of \catc.

If \catcw (along with $\kappa$) is a pu-catgeory then each object of \catcw is
classified by $\kappa$  as a \term{p-object} or as a \term{u-object}. 

u-objects and p-objects are so named because I
think of a u-object as a type all of whose instances are universals and I think of a p-object as a type
all of whose instances are particulars. 
\end{aside}

\begin{newtt}
I can model particular singleton type by a monomorphism to the terminal object. Therefore
I can insits that $1$ is universal and still have universal-like instances of types of particulars.
\end{newtt}

The category $\universals$ has upto isomorphisms a single coproduct opreserving instance in \Set. 
This is the hom functor $Hom_{\universals}(1,\_)$.

It is required that an instance of the category \catcw  generated by a sketch considered as a data specification relative to  the category $\universals$ is a functor $D: \catc \morph Set$ such
that for all objects $x \in \kappa^{-1}(p)$, the set $D(x)$ is finite.

Life would be simpler without this finiteness condition but I don't think it realistic not to allow non-finte types of particulars.

When we present a directed graph of a sketch for a supercategory of $\universals$ we need only include those
objects of $\universals$ that are codomains of objects within  $\kappa^{-1}(p)$.

\begin{oldtt}
\subsection*{Discussion (weak)}
At least some of These theories above are aguably logical data specifications.

To define a complete data specification consider the catgeory with specified mono-sources
and terminal object generated by the logical specification. 
\end{oldtt}

\section{Structurally Annotated Logical Data Specifications}
A structural annotation for a logical data specification consists of a 
$\omega$-tree structure on the objects of the generated category \catcw
along with distinguished morphisms $p_b: b \morph a$ whenever $a \base b$ in the  $\omega$-tree
such that the terminal object is the root of the $\omega$-tree.

A logical data specification is not complete and ready for use until it is structurally annotated.

The distinguished morphisms in the annotation represent part/part-of relationships. These are sometimes known as composition relationships. They are specified as relationships to be implmented by structural containment.

The same logical data specification may be used in a single system with different structural annotations.
One annotation may represent the data as it is held in a database, another as it is passed in messages between one program and another.

The struturally annotated logical data specification we shall say is a structured data specification.

The structured data specification  can be depicted by showing a directed graph with
distinguished structural relationships depicted with triangular headed arrows.

\section*{Terminal Object - the Absolute -- the Whole}
In a structured data specification there needs be a representation of the terminal object.

The terminal object in a structured data specification represents the concept of The Absolute or The Whole of Everything.


\section*{Structured Data Specification -- A Set of Named Labelled Directed Graphs -- Organised by nesting nodes with graphs, outgoing edges within nodes}
Shows the terminal object as `abs'. It represents the whole of everything which in this case is a set of directed graphs.
\begin{displaymath}
\begin{array}{cp{0.75cm}c}
\Rnode{abs}{abs}                       \\[1cm]
\structuralsetofdg   &&  \Rnode{u}{u} 
\end{array}
\begin{arrows}
\ncsar{dg}{abs}
\ncarr{dg}{u}
\alabel{name}
\idcomp
\ncarr{node}{u}
\alabel{label}
\idcomp
\ncarr{edge}{u}
\blabel{label}
\idcomp
\structuraldgsrcedge  % redrawn so that I can bar it with \idcomp
\idcomp
\structuralnodepartof  % repeat so that I can bar with \idcomp
\idcomp
\end{arrows}
\end{displaymath}

\subsection*{Abstract syntax}
Data structure represented in abstract syntax inspired by CarnegieMelon IDL:
\begin{verbatim}
abs => Set Of dg

dg => Set Of node

node => label: u,
        Set Of edge


edge => label : u,
        targetlabel: u

\end{verbatim}
\end{document}


\section*{Thought}
Rerun some of the above with alternative notations. Bachman. Chen. Barker and myself.

This is an example of a foreign key. They are the lifeblood tying data togethe rin relational databases. 
When data is organised hierarchically then it is tied togther by containment which is then argmented by foreign keys.
Foregin keys are explicitly suppoerted in xml or in IDL but they are extensively of necessity because data isn't as a rule puelry hierarchic in structure.