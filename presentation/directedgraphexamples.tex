 \documentclass[10pt,a4paper]{article}
%\input{thepreamble.tex}
\input{../SharedMacros/ccategories.macros}
\input{../SharedMacros/ermacros}
\input{../SharedMacros/erdiagram}
\input{../SharedMacros/theorems.macros}
\input{../SharedMacros/general.macros}
\usepackage{mathptmx}  % This changes font to roman
\usepackage{anyfontsize}
\usepackage{mathtools}  % why have we got this?
\usepackage{alltt}    
\usepackage{mnsymbol} %used for rightpitchfork
\usepackage{cmll}
\usepackage{ulem}
\renewcommand{\ttdefault}{txtt}
\usepackage[left=1.5cm, right=4cm, marginparwidth=3cm, top=2cm, bottom=2.0cm]{geometry}
\usepackage{framed}
\usepackage[font=small]{caption}
\setlength{\captionmargin}{2cm}
\theoremstyle{remark}
\newtheorem*{lemma*}{Lemma}

\usepackage{arydshln} % vertical dashed lines between columns of an array


\renewcommand{\term}[1]{\textit{#1}}  %SIMPLE UNINDEXED VERSION

%ENDCOPY

\begin{document}
\title{Directed Graph Examples}

% abstract here for ams

\author{John Cartmell}

\date{}

%\maketitle



\newcommand{\seenudgeup}[1]{\rule{0.1cm}{#1}}
\newcommand{\seenudgedown}[1]{\rule[-#1]{0.1cm}{0.1cm}}
\newcommand{\nudgeup}[1]{\rule{0cm}{#1}}
\newcommand{\nudgedown}[1]{\rule[-#1]{0cm}{0.1cm}}

\newcommand{\sourcediag}[5]  %copied fron preparation paper
{$
\begin{array}{c p{0.5cm} c  }
             &&   \Rnode{b}{#2} \\[0.01cm]
\Rnode{a}{#1} &&                \\[0.01cm] 
             &&   \Rnode{c}{#3} 
\end{array} 
\begin{arrows}
\ncarr{a}{b}
\alabel{#4}
\ncarr{a}{c}
\blabel{#5}
\end{arrows}
$  
}
% Example of above: \newcommand{\fgsourcediag}{\sourcediag{a}{b}{c}{f}{g}}

\newcommand{\dgsrcedge}
{
\setlength{\arroffsetA}{3pt}
\setlength{\arroffsetB}{3pt}
\ncarr[5]{edge}{node} 
\arreset  
}
\newcommand{\structuraldgsrcedge}
{
\setlength{\saroffsetA}{3pt}
\setlength{\saroffsetB}{3pt}
\ncsar[5]{edge}{node} 
\sarreset 
}
\newcommand{\dgtargetedge}
{
\setlength{\arroffsetA}{-3pt}
\setlength{\arroffsetB}{-3pt}
\ncarr[-5]{edge}{node} 
\arreset   
}
\newcommand{\dgbasic}
{
\begin{array}{c}
\Rnode{node}{node}  \\[2cm]
\Rnode{edge}{edge}       
\end{array}
\begin{arrows}
\dgsrcedge
\alabel{src}
\dgtargetedge
\blabel{trg}
\end{arrows}    
}
\newcommand{\structuraldgbasic}
{
\begin{array}{c}
\Rnode{node}{node}  \\[2cm]
\Rnode{edge}{edge}       
\end{array}
\begin{arrows}
\structuraldgsrcedge
\alabel{src}
\dgtargetedge
\blabel{trg}
\end{arrows}    
}

\newcommand{\nodepartof}
{
\ncarr{node}{dg}     
}
\newcommand{\structuralnodepartof}
{
\ncsar{node}{dg}     
}
\newcommand{\setofdg}
{
\begin{array}{c}
\rnode{dg}{dg} \\[2cm]
\dgbasic
\begin{arrows}
\nodepartof
\end{arrows}
\end{array}
}

\newcommand{\structuralsetofdg}
{
\begin{array}{c}
\rnode{dg}{dg} \\[2cm]
\structuraldgbasic
\begin{arrows}
\structuralnodepartof
\end{arrows}
\end{array}
}


\section{Theories and Logical Data Specifications}

\section*{Theory of a directed graph}
\begin{displaymath}
\dgbasic
\end{displaymath}

\section*{Theory of a set of directed graphs}
\begin{displaymath}
\setofdg
\end{displaymath}

\section*{Theory of a labelled directed graph}

\begin{displaymath}
\begin{array}{cp{0.75cm}c}
\dgbasic   &&  \Rnode{l}{l} 
\end{array}
\begin{arrows}
\ncarr{node}{l}
\alabel{label}
\ncarr{edge}{l}
\blabel{label}
\end{arrows}
\end{displaymath}



\section*{Theory of a labelled directed graph with uniquenes of labels }
\subsection*{Edge labels unique across the whole graph}
\begin{displaymath}
\begin{array}{cp{0.75cm}c}
\dgbasic   &&  \Rnode{l}{l} 
\end{array}
\begin{arrows}
\ncarr{node}{l}
\alabel{label}
\idcomp
\ncarr{edge}{l}
\blabel{label}
\idcomp
\end{arrows}
\end{displaymath}
\subsection*{Edge labels unique within edges leaving a node (eg a state transition diagram)}

Specify  that this source \sourcediag{edge}{node}{l}{src}{label} is  a monosource. A 
rough and ready notation for this is to bar arrows that participate in the mono source as so:

\begin{displaymath}
\begin{array}{cp{0.75cm}c}
\dgbasic   &&  \Rnode{l}{l} 
\end{array}
\begin{arrows}
\ncarr{node}{l}
\alabel{label}
\idcomp
\ncarr{edge}{l}
\blabel{label}
\idcomp
\dgsrcedge  % redrawn so that I can bar it with \idcomp
\idcomp
\end{arrows}
\end{displaymath}

If two different monosources to be specfied at the same node then can still be shown 
on a single diagram if the bars are subscripted i.e. labelled.

\begin{oldtt}
\subsection*{Theory of a set of uniquely named labelled directed graphs with edge labels unique within edges leaving a node}

\begin{displaymath}
\begin{array}{cp{0.75cm}c}
\setofdg   &&  \Rnode{l}{l} 
\end{array}
\begin{arrows}
\ncarr{dg}{l}
\alabel{name}
\idcomp
\ncarr{node}{l}
\alabel{label}
\idcomp
\ncarr{edge}{l}
\blabel{label}
\idcomp
\dgsrcedge  % redrawn so that I can bar it with \idcomp
\idcomp
\nodepartof  % repeat so thatI can bar with \idcomp
\idcomp
\end{arrows}
\end{displaymath}
\end{oldtt}


\subsection*{Theory of a set of uniquely numbered text labelled directed graphs with edge labels unique within edges leaving a node}
\newcommand{\stringtype}{text}
\newcommand{\numbertype}{number}
\begin{displaymath}
\begin{array}{cp{1.0cm} : p{0.5cm}c}
\setofdg   &&&  
\begin{array} {l}
\Rnode{text}{}\stringtype \\[1cm]
\Rnode{number}{}\numbertype 
\end{array}
\end{array}
\begin{arrows}
\ncarr{dg}{text}
\alabel{name}[0.3]
\idcomp
\ncarr{node}{number}
\alabel{label}[0.3]
\idcomp
\ncarr{edge}{number}
\blabel{label}[0.3]
\idcomp
\dgsrcedge  % redrawn so that I can bar it with \idcomp
\idcomp
\nodepartof  % repeat so thatI can bar with \idcomp
\idcomp
\end{arrows}
\end{displaymath}

In this example nodes to the right of the dashed line are required to have a fixed interpretation in $\Set$.

The way that Johnson et al. arrange for this is by defining these types to be codproducts of morphisms 
from the terminal object and by defining instances to be coproduct preserving. 
This is pretty neat because cardinality concerns aside (of which more later) 
each functor $Hom_\catc(x,_)$ functor is then an instance where \catcw is the category generated by the sketch and $x$ is any object of \catc.

This is the most important charcateristic of a theory that can be considered a data specification. 
Certain types have fixed interpretations. These are sometimes referred to as scalar types or primitive types.
Sometimes called domains. Johnson et al refer to them as attributes.
These are of two kinds
\begin{enumerate}
\item the types which are built in to programming languages and data specification languages:  $float$, $int-32$, $int-64$, $char$, $varchar$, $string$ and so on.
\item types that are user-defined as enumerations of values. Color might be defined as 
consisting of the values $red$, $green$ and $blue$. 
\end{enumerate}

The approach of Johnson at al. treats these two kinds of types the same way for theory purposes. 

What is important to me at least is that there are no morphisms that leave the right hand side of this diagram and enter the left hand side.


\section{Universals and Particulars}
The generic style of data specification system
that we describe here involves definition of types of particulars in terms of their relationships with other types,
of which there are two kinds, those, such as represent numbers, character strings, booleans and so on, all of
whose instances are universals and, the definienda, those types all of whose instances are particulars. The binary many-one data relationships  are functional in character and can be though of as the edges of a graph whose nodes comprise all types - both the types of particulars and the types of universals. 


The terminology used is diverse. For edges that cross the divide from left to right in this diagram 
in entity relationship modelling 
are said to be attributes whereas in relational data modelling they are presented as columns of tables; types all of whose instances are universals  are said to be \textit{attribute types} in entity relational 
modelling, though  these are called \textit{attributes} by Johnstone et al.; in the initial work by  Chen such types were called \textit{value sets}; they are said to be \textit{domains} in relational data modelling theory. 

\newcommand{\Veee}{V}
\newcommand{\veee}{v}
Types of particulars are said to be 
types of entities or \textit{entity types} in modern entity relational modelling
or sometimes, confusingly, just \textit{entities}  and 
are modelled as \textit{relational tables} in relational data modelling. 

\subsection*{Discussion (weak)}
At least some of These theories above are aguably logical data specifications.

To define a complete data specification consider the catgeory with specified mono-sources
and terminal object generated by the logical specification. 


\section{Structurally Annotated Logical Data Specifications}
A structural annotation for a logical data specification consists of a 
$\omega$-tree structure on the objects of the generated category \catcw
along with distinguished morphisms $p_b: b \morph a$ whenever $a \base b$ in the  $\omega$-tree
such that the terminal object is the root of the $\omega$-tree.

A logical data specification is not complete and ready for use until it is structurally annotated.

The distinguished morphisms in the annotation represent part/part-of relationships. These are sometimes known as composition relationships. They are specified as relationships to be implmented by structural containment.

The same logical data specification may be used in a single system with different structural annotations.
One annotation may represent the data as it is held in a database, another as it is passed in messages between one program and another.

The struturally annotated logical data specification we shall say is a structured data specification.

The structured data specification  can be depicted by showing a directed graph with
distinguished structural relationships depicted with triangular headed arrows.

\section*{Terminal Object - the Absolute -- the Whole}
In a structured data specification there needs be a representation of the terminal object.

The terminal object in a structured data specification represents the concept of The Absolute or The Whole of Everything.


\section*{Structured Data Specification -- A Set of Named Labelled Directed Graphs -- Organised by nesting nodes with graphs, outgoing edges within nodes}
Shows the terminal object as `abs'. It represents the whole of everything which in this case is a set of directed graphs.
\begin{displaymath}
\begin{array}{cp{0.75cm}c}
\Rnode{abs}{abs}                       \\[1cm]
\structuralsetofdg   &&  \Rnode{u}{u} 
\end{array}
\begin{arrows}
\ncsar{dg}{abs}
\ncarr{dg}{u}
\alabel{name}
\idcomp
\ncarr{node}{u}
\alabel{label}
\idcomp
\ncarr{edge}{u}
\blabel{label}
\idcomp
\structuraldgsrcedge  % redrawn so that I can bar it with \idcomp
\idcomp
\structuralnodepartof  % repeat so that I can bar with \idcomp
\idcomp
\end{arrows}
\end{displaymath}

\subsection*{Abstract syntax}
Data structure represented in abstract syntax inspired by CarnegieMelon IDL:
\begin{verbatim}
abs => Set Of dg

dg => Set Of node

node => label: u,
        Set Of edge


edge => label : u,
        targetlabel: u

\end{verbatim}
\end{document}


\section*{Thought}
Rerun some of the above with alternative notations. Bachman. Chen. Barker and myself.

This is an example of a foreign key. They are the lifeblood tying data togethe rin relational databases. 
When data is organised hierarchically then it is tied togther by containment which is then argmented by foreign keys.
Foregin keys are explicitly suppoerted in xml or in IDL but they are extensively of necessity because data isn't as a rule puelry hierarchic in structure.