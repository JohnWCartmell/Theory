

Good engineering is so described because it reduces the potential for error and mishap but, across disciplines, the distinction between the  good, the less good and the downright  bad is not always clear cut nor well defined.
Badly engineered data and systems are not necessarily inadquate for a purpose at hand but they are more error prone. With this in mind, we seek to give clear principles that distitinguish the good from the bad in the area of  data specifications.

In this section we formulate two general goodness principles which are applicable to  the model of data specification that we are investigating here
 --- sketches of categories. as data specifications. 
We phrase these as principles that `ought to' hold of a data specification with respect to a requirement. 
The two principles together provide an objective definition  of goodness. 

\subsubsection{The Principle of No Redundancy}
Within an individual data specification, redundancy of data is a bad thing. This is our first principle and it can be encoded mathematically as a property of a data specification as follows:

\textbf{Goodness Principle 1} If a sketch $S$ for a category \catcw 
is considered as a data specification then  there ought to be no subsketch of $S$ which is a sketch of \catcw. 

\textbf{Example} In the example given above of the sketch for the relational meta model, 
the edge $S_1$ in the presence of the path equivalence (\ref{rdbR1scope}) is redundant. This model therefore fails to meet goodness principle 1.

\subsubsection{The Principle of Maximal Constrainedness}

Data specifications enable data and structurally constrain it. The means of constraint are limited and vary between methods. For this reason, generally, more data fits a data specification than is required for a particular purpose.  The principle of maximal constrainedness is that this gap between what is structurally possible and what is required should be kept to a minimum. This is our second principle 
--- the principle of maximal constrainedness states that a data specification should constrain the data that meets it as closely as is possible to the data required for the purpose at hand. 

Expressed in logical terms, a theory usually has some slack by which we mean that it has structurally compliant instances that are not part of its requirement.  The definition of maximal constrainedness expresses that a theory is maximally constrained to its requirement if there is no way of extending the theory so as to rule out possible structurally compliant instances that are not part of the requirement (i.e. to rule out slack) while at the same time remaining consistent with the requirement. The theory should fit the facts as tightly as possible.

Formulated precisely, maximum constrainedness  is a property of the category $\catc$ generated by the sketch  rather than of the sketch itself and is defined  relative to a requirement $\reqtc$ by which we mean a set of 
instances where each instance is a functor $D$, $D: \catc \morph \Fin$. In what follows, therefore,  by a requirement $\reqtc$ for category $\catc$ we mean a set  $\reqtc \subseteq | \Fin^{\catc} |$. 

The definition now follows, preceded by an auxiliary definition.
\begin{definition}
If $\catc$ is a category and $\reqtc$ is a requirement for $\catc$,  if $I: \catc \morph \catcp$ is a functor then say that $I$ is \term{consistent with} requirement $\reqtc$ iff for all instances $D \in \reqtc$ there exists a unique functor $D':\catcp \morph \Fin$ such that $I \circ D'=D$.
\end{definition}
\newcommand{\IfSforCwithRCwords}{If $S$ is a sketch for category \catcw and if $S$ is considered as a data specification with requirement $\reqtc$\ }
\begin{definition}
 \IfSforCwithRCwords then define \catcw to be \term{maximally constrained} to the requirement $\reqtc$ iff for all categories $\catcp$ and for all functors $I:\catc \morph \catcp$ that are consistent with $\reqtc$, for all functors $F: \catc \morph \Fin$  there exists a  $F' : \catcp \morph \Fin$ such that $I \circ F'=F$. 
\end{definition}

\textbf{Goodness Principle 2:}
\IfSforCwithRCwords then \catcw ought to be be maximally constrained to $\reqtc$. 

