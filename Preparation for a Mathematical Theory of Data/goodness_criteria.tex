In this section we state two primary and three secondary goodness criteria for sketches considered as data specifications. Each criteria is expressed as a principle which `ought to' hold. One of these principles (principle 2B, below) is an archetypal precursor to Codd's third normal form principle. 
Such principles as these are principles that ought to be followed in the interests of good engineering. Not following them increases the liklihood of bugs and software inefficiencies.   

\subsubsection{The Principle of No Redundancy}
\textbf{Goodness Principle 1:} If a sketch $S$ for a category \catcw 
is considered as a data specification then  there ought to be no subsketch of $S$ which is a sketch of \catcw. 

Rationale: Redundant edges lead to redundant data. Redundant diagrams give rise to unnecessary program logic.

\textbf{Example} In the example given above of the sketch for the relational meta model 
the edge $S_1$ and the path equivalence (\ref{rdbR1scope}) are redundant. This model therefore fails this 
goodness criteria. 
\subsubsection{The Requirement}
\subsubsection{The Principle of Maximal Constrainedness}
Maximum constrainedness, as mentioned above, is a property of the category $\catc$ generated by the sketch  rather than of the sketch itself and is defined  relative to a requirement $\reqtc$ by which we mean a set of 
instances where each instance is a functor $D$, $D: \catc \morph \Fin$. In what follows, therefore,  by a requirement $\reqtc$ for category $\catc$ we mean a set  $\reqtc \subseteq | \Fin^{\catc} |$. 

Consider, a theory usually has some slack by which we mean that it has structurally compliant instances that are not part of its requirement.  The definition of maximal constrainedness expresses that a theory is maximally constrained to its requirement if there is no way of extending the theory so as to rule out possible structurally compliant instances that are not part of the requirement (i.e. to rule out slack) whilst remaining consistent with the requirement.

The definition now follows, preceded by an auxiliary definition.
\begin{definition}
If $\catc$ is a category and $\reqtc$ is a requirement for $\catc$,  if $I: \catc \morph \catcp$ is a functor then say that $I$ is \term{consistent with} requirement $\reqtc$ iff for all instances $D \in \reqtc$ there exists a unique functor $D':\catcp \morph \Fin$ such that $I \circ D'=D$.
\end{definition}
\newcommand{\IfSforCwithRCwords}{If $S$ is a sketch for category \catcw and if $S$ is considered as a data specification with requirement $\reqtc$\ }
\begin{definition}
 \IfSforCwithRCwords then define \catcw to be \term{maximally constrained} to the requirement $\reqtc$ iff for all categories $\catcp$ and for all functors $I:\catc \morph \catcp$ that are consistent with $\reqtc$, for all functors $F: \catc \morph \Fin$  there exists a  $F' : \catcp \morph \Fin$ such that $I \circ F'=F$.
\end{definition}

\textbf{Goodness Principle 2:}
\IfSforCwithRCwords then \catcw ought to be be maximally constrained to $R_C$. 

\subsubsection{The Principle of the Representation of Equivalent Paths -- Logical Completness}

\newcommand{\fgparalleldiag}
{
 $
\rule[-0.3cm]{0pt}{0.9cm} %to add vertical space of diagram -- based on lowering diagram 0.3cm and heght 0.9cm
                            % change thickness from 0pt to 1 pt to debug
\begin{array}{c p{0.5cm} c  }
 \Rnode{a}{a}            &&   \Rnode{b}{b}
\end{array} 
\begin{arrows}
\ncarc[nodesep=2pt,arcangle=10,offset=2pt]{->}{a}{b}
\alabel{f}
\ncarc[nodesep=2pt,arcangle=-10,offset=-2pt]{->}{a}{b}
\blabel{g}
\end{arrows}
$  
}

\newcommand{\pequiv}[1][R_C]{\underset{#1}{\equiv}}

\begin{definition}
If $\catcw$ is a  category, if $\reqtc$ is a set of instances
 and if \fgparalleldiag in $\catc$, then say that path $f$ is equivalent to path $g$ with respect to the requirement $R_C$ 
 (and write $f \pequiv g$) iff
in all instances $D \in \reqtc$, $D(f)=D(g)$.
\end{definition}

\begin{definition}
If $\catc$ is a  category and $\reqtc$ is a set of instances,
 and if \fgparalleldiag in $\catc$ such that $f \pequiv g$
 then say that the path equivalence $f \pequiv g$ is represented in \catcw iff
 $f=g$.
\end{definition}

\begin{oldtt}
\begin{definition}
If $\catc$ is a  category and $\reqtc$ is a set of instances,
 then say that  $\catc$ is \term{equationally complete} with respect 
to the requirement $\reqtc$ iff all path equivalences with respect to $R_C$ are represented in \catcw 
i.e. iff for all diagrams \fgparalleldiag in $\catc$,  
if in all instances $D \in \reqtc$, $D(f)=D(g)$,  then $f=g$ in $\catc$.
\end{definition}
\end{oldtt}

\textbf{Goodness Principle 2A:} \IfSforCwithRCwords then \catcw should be equationally complete with respect to $R_C$ that is all path equivalences with respect to $R_C$  ought to be represented in \catc.

\subsubsection{The Principle of the Representation of Functional Dependencys}

\begin{definition}
If $\catc$ is a category and $\reqtc$ is a set of instances and if \fgsourcediag
in $\catc$ then there is a  \term{functional dependency} of $g$ on $f$ with respect to $\reqtc$ iff
there is a family of functions $H_D)_{D \in \reqtc}$ such that 
in each instance $D$, $H_D$ is a unique function $H_D: D(b) \morph D(c)$, such that $D(f) \circ H_D = D(g)$. 
If there is such a functional dependency then we say that $\fundep{H}{f}{g}$ in $\catc$ with respect to $\reqtc$.
\end{definition}

Our use of the $\morph$ notation for functional dependencies here is coming from relational database theory where it is usual to represent such a functional dependency as we have here by asserting that 
$$
f \morph g
$$
Note that this use of an $\morph$ notation is independent of our use of $\morph$ as a morphism of a category 
or, for that matter, as an edge in a presentation. Neither are we alluding to a bicategory structure. We have two distinct uses for $\morph$ (three if you distinguish arrows in presentations from arrows in categories). Any particular use will be unambiguous in context.

\begin{definition}
If $\catc$ is a category and $\reqtc$ is a set of instances, if
\fgsourcediag
in $\catc$ 
and if there is a functional dependency $\fundep{H}{f}{g}$ then say that 
the functional dependency $H$ is \term{represented} in $\catc$ 
iff there exists a morphism $h:b \morph c$ in $\catc$ 
\oldt{such that for each instance $D \in \reqtc$, $D(h)=H_D$}
such that $f \circ h =g$.
\end{definition}

\textbf {Goodness Principle 2B:} \IfSforCwithRCwords then all functional dependencies present in $R_C$
ought to be represented in \catc.


\subsubsection{The Principle of the Representation of Referential Inclusion Dependencies}

\begin{definition}
If $\catc$ is a category and $\reqtc$ is a set of instances 
and if
\fnsourceqnsource
in $\catc$, then an \term{inclusion dependency} $I$, written $a[f_1,...f_n] \overset{I}{\subseteq} c[q_1,..q_n]$, is a family of functions $I_D)_{D \in \reqtc}$
such that each instance $D \in \reqtc$, $I_D$ is a function $I_D : D(a) \morph D(c)$ such that
for each $i$, $1 \leq i \le n$, $I_D \circ D(q_i) = D(f_i)$.
\end{definition}

If each function in this family is the unique such function then the inclusion dependency is said to be referential. Just to be clear the definition is this:
\begin{definition}
If $\catc$ is a category and $\reqtc$ is a set of instances 
and if
\fnsourceqnsource
in $\catc$, then a \term{referential inclusion dependency} $I$, written $a[f_1,...f_n] \overset{I}{\subseteq} c[q_1,..q_n]$, is a family of functions $I_D)_{D \in \reqtc}$
such that each instance $D \in \reqtc$, $I_D$ is a unique function $I_D : D(a) \morph D(c)$ such that
for each $i$, $1 \leq i \le n$, $I_D \circ D(q_i) = D(f_i)$.
\end{definition}




\begin{definition}
If $\catc$ is a category and $\reqtc$ is a set of instances and if
\fnsourceqnsource
in $\catc$ and if $a[f_1,...f_n] \overset{I}{\subseteq} c[q_1,..q_n]$ is a referential inclusion dependency
with respect  to $\reqtc$ then say that the inclusion dependency $I$ is \term{represented} in $\catc$
iff there exists a morphism $i:a \morph c$ in $\catc$ such that in each instance $D \in \reqtc$, $D(i) = I_D$. 
\end{definition}

\textbf {Goodness Principle 2C:} \IfSforCwithRCwords 
then all referential inclusion dependencies present in $R_C$
ought to be be represented in \catc.