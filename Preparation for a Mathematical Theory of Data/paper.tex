 

\documentclass[10pt,a4paper]{article}

%\input{thepreamble.tex}
\input{../SharedMacros/ccategories.macros}
\input{../SharedMacros/ermacros}
\input{../SharedMacros/erdiagram}
\input{../SharedMacros/theorems.macros}
\usepackage{mathptmx}  % This changes font to roman
\usepackage{anyfontsize}
\usepackage{mathtools}  % why have we got this?
\usepackage{alltt}    
\usepackage{mnsymbol} %used for rightpitchfork
\usepackage{cmll}
\usepackage{ulem}
\renewcommand{\ttdefault}{txtt}
\usepackage[left=1.5cm, right=4cm, marginparwidth=3cm, top=2cm, bottom=2.0cm]{geometry}
\usepackage{framed}
\usepackage[font=small]{caption}
\setlength{\captionmargin}{2cm}
\theoremstyle{remark}
\newtheorem*{lemma*}{Lemma}
\newcommand{\catc}[1][C]{\textbf{#1}}
\newcommand{\catcp}[1][C]{\textbf{#1}'}
\newcommand{\reqt}{\textbf{R}}
\newcommand{\reqtc}[1][\catc]{\reqt_{#1}}
\newcommand{\Fin}{\ensuremath{\textbf{Fin}} }
\newcommand{\Finp}{\ensuremath{\textbf{Finp}} }
\newcommand{\Po}{\ensuremath{\textbf{Po}} }
\newcommand{\fundep}[3]{#2 \xrightarrow{#1} #3}
\newlength{\oldparindent}
\setlength{\oldparindent}{\parindent} % Save \parindent before of change
\setlength{\parskip}{0.5\baselineskip} % Definition of `parskip`
\setlength{\parindent}{0pt}
\newcommand{\ind}{\hspace*{\oldparindent}}
\newcounter{para}
\newcommand\note{\par\ind\refstepcounter{para}\thepara.\space}


%COPY
%quine quote
\newcommand{\qq}[1]{
\left\ulcorner#1\right\urcorner
}

\newcommand{\term}[1]{\textit{#1}}  %SIMPLE UNINDEXED VERSION

%ENDCOPY

\begin{document}
\title{Preparation for a Mathematical Theory of Data}

% abstract here for ams

\author{John Cartmell}

\maketitle
\iffalse
\begin{center}
DRAFT
\end{center}
\fi



\section{Background}
\note
Methods for describing the structure of data occur in programming languages, where they vary depending on
the model of computation (object-oriented, functional,symbolic and so on);
they occur as dedicated specification methods, such is the entity relationship method,
and  in database technologies, where they vary by the data model (relational, hierarchical, nested relational,
graph based). Finally they underlie interfacing technologies which are either binary such as 
the many that implement some variant of IDL (Interface Definition Language) or text based such as XML. 

\note 
There are similarities between the methods when they are viewed abstractly but there are significant differences too and so a study of these different methods brings us to many \textit{essentially distinct} notions of data specification.

\note
When viewed abstractly each data specification is a theory of what is and  to each different notion of data specification corresponds a different notion of theory. An organisation of this thinking will constitute a mathematical theory of data. Such a mathematical theory of data has a role to play in improving  the way we think, talk about, design, develop, and transform, data specifications and in fostering significant improvements in available techniques and tools for their management. 

\note 
The relational model of data ubiquitously underpinning databases for fifty years or so, is exceptional in that it has a body of theory; this theory includes quality criteria  distinguishing good data specifications from bad. 
One of the goals of a mathematical theory of data is to enable these relational prescriptions of goodness
to be generalised to become generally applicable. The \textit{dry run} below suggests this is possible.

\note
Data is required for a purpose, generally to describe real world things in some or other context. This constitutes an intended usage for a data specification. Of all structurally compliant instances of a data specification some are required for the intended usage and, generally speaking, some not.
Notionally let there be a requirement $R$ that equates to a subset of the set of all compliant data instances 
of a data specification and serving to characterise its intended use. 

\note 
There are two self-complementing principles of good engineering of data specifications. Firstly, within each particular methodology a data specification should be as constraining as possible of data instances whilst being general enough for the intended usage; equivalently the corresponding theory should fit as tightly as possible to the facts. Secondly, redundancy of data is to be avoided. This second principle is modulated by computational cost for it would be unreasonable not to hold in data all prime factors of a number on account of them being computable and therefore redundant.

\note 
Meeting the first principle we will describe as achieving \term{maximum constrainedness} for the data specification.
To maximise constrainedness will be to come as  close as we can within any given methodology with given syntax to meeting a formal objective described by Zaniola \cite{zaniolo1982} in the context of relational schema design (data specification, that is, for the relational model of data)  as `the complete \textit{representation} of semantic constraints' (his italics). Zaniola subsequently refers to this as `the representation principle'.

\note
From the two principles we can phrase goodness criteria  for data specifications with respect to requirements $\reqt$
i.e. to intended usages. In the context of relational data design, 3rd, 4th and 5th normal forms are examples of such goodness criteria. 

\note
When viewed abstractly many distinct notions of data specification can be characterised as having
data specifications corresponding to finite presentations of either categories or, if missing data is to be allowed, $\Po$-enriched categories with some additional structure such as certain limits and/or colimits.

\note
Compliant instances of such data specifications correspond to structure preserving functors from the corresponding category to the category of finite sets $\Fin$ or to the category of finite sets and partial functions $\Finp$.

\note
Redundancy of objects or arrows in a presentation corresponds to redundancy of data in instances of a data specification. 
By the second principle it is the goal of data specification to avoid such redundancy. 

\note
Goodness equates to absence of redundancy plus maximal constrainedness to intended usage. Absence of redundancy is a property of a presentation. Maximal constrainedness
is a property of the category $\catc$ generated by the presentation and is relative to a requirement $\reqtc$, where $\reqtc$ is a set of instances where each instance is structure preserving functor $D$, $D: \catc \morph \Fin$, where
$\Fin$ is the category of finite sets and functions (or, subsequently, to other variants of the category of sets and functions as appropriate).

\note 
Codd \cite{Codd1970} proposes the relational model of data; he gives the first prescription of goodness for
a relational data specification and describes how it might be achieved through a method which he calls normalisation\cite{Codd1970}\footnote{He also introduces the term foreign key in this first paper and includes a discussion of redundancy of data.}. 
Codd  subsequently defines a third normal form (3NF) \cite{Codd1971} for which purpose he introduces 
the concept of a functional dependency.
The definition of third normal form extends the notion of goodness and the method for achieving it\footnote{By \cite{Codd1971} the stage was set 
for describing conditions of goodness in terms of relational schemas being in normal form -- an  unfortunate terminology  because these schemas that meet the condition
are not canonical in any way as a mathematician might be led to believe from the terminology.}.

\note Boyce-Codd normal form (BCNF) is a stronger normal form and one that it is not always possible to meet. Zaniola \cite{zaniolo1982}) most clearly elaborates the difference between 3NF and BCNF. 
In Zaniola's description, specifications that are in BCNF meet the representation principle in regard to having all functional dependencies represented in them.

\note Further standards that a good relational data specification should adhere to were formulated by Fagin \cite{Fagin1977} (fourth normal form) and  \cite{Fagin1979} (projection-join normal form also known as fifth normal form)
using the concept of multi-valued dependencies. 
One paraphrasing would be that it isn't good to store needless copies of data. 
When formulated in category theory this will come down to not needlessly including limit objects in a presentation.

\note In a different direction many authors describe forms of redundancy in data that are immune to prescriptions
of previous normal forms (up to 5th normal form, say) and to remedy this give definitions of normal forms that
take account of inclusion dependencies.
There isn't a single clear concept that arises from this work but the deficiency and the need for a remedy is very clear.  
Inclusion dependencies, like functional dependencies and multi-valued dependencies, are forms of semantic constraint in the sense that this term is used by Zaniola. 

\note Here we focus on inclusion dependencies that are referential. These in dry run are the equivalents of what elsewhere in the context of relational data specification are referred to as a key-based or a superkey-based inclusion dependencies [\cite{Mannila1986}, \cite{Levene2000}]
or, more pragmatically, as referential constraints\footnote{	Also known colloquially, and rather horribly in my opinion, as foreign key constraints}in the ISO SQL standard\cite{ISOSQL2016} and in relation to XML
(\cite{fan2003}, for instance); whether implicitly, or explicitly as in the relational paradigm, these are lynchpins of  data specifications.

\note Various authors (\cite{Alderson97},\cite{Johnson93}) have noted the importance of commutative diagrams in data specifications.
Commutative diagrams are another kind of semantic constraint -- we can call them commutivity constraints but equally they might be called path equivalence constraints.  The fact is that relational designs fairly frequently have some commutivity constraints implicitly represented within  and this having been achieved  by designers following prescriptions to normalise data and to eliminate duplicates rather than with awareness of the underlying commutivity. 
Shlaer and Lang illustrate this in \cite{Shlaer96} where they describe alternative paths between two nodes as
relationship loops, when distinct paths are equivalent they say that there are dependencies
between the relationships. Kolp and Zimnyi ((\cite{Kolp1995})) instead use the term
relationship cycle and identify such as a source of superfluous attributes in the
transformation from ER model to relational model.



\section{Examples of Path Equivalences aka Commutative Diagrams}

A data specification for the relational model of data (in other words, the data specification that is the relational meta-model) when viewed abstractly as a directed graph
is always going to include nodes corresponding to the concepts of table ($t$) , column ($c$), foreign key constraint ($fk$) and foreign key element ($fke$) as well as others
\iffalse
\raisebox{-0.7cm}
{\footnotesize
\begin{tabular}{cp{0.75cm}cp{13cm}}
                 &$t$&    &  table  \\ [0.1cm]
                 &$c$&    & column  \\ [0.1cm]
                &$fk$&    & foreign key -- consists of one or more foreign key elements \\[0.1cm]
               &$fke$&    & foreign key element --  associates a referencing column and a referred to column. 
\end{tabular}	
}
\vspace{0.25cm}
\fi
and is also going to include the following edges:	\\
\begin{tabular}{p{1cm} c}
&
{\footnotesize
$		
\begin{array}{cp{0.75cm}cp{13cm}}	
                                                                  \\			
\Rnode{c}{c}      && \Rnode{t}{t}   & the parent table of a column\\[0.2cm]   
\Rnode{fk}{fk}    && \Rnode{t2}{t}  & the parent table of a foreign key\\[0.2cm] 
\Rnode{fke}{fke}  && \Rnode{fk2}{fk}& the foreign key a foreign key element is part of\\[0.2cm]  
\Rnode{fk3}{fk}   && \Rnode{t3}{t}  & the table that the foreign key defines a reference to\\[0.2cm]     
\Rnode{fke2}{fke} && \Rnode{c2}{c}  & the referencing column identified by the foreign key element\\[0.2cm]     
\Rnode{fke3}{fke} && \Rnode{c3}{c}  & the referred to column identified by the foreign key element         
\end{array}
$
\ncarr{c}{t}
\alabel{p_c}
\ncarr{fk}{t2} 
\alabel{p_f}
\ncarr{fke}{fk2}
\alabel{p_e}
\ncarr{fk3}{t3} 
\alabel{r_0}
\ncarr{fke2}{c2}
\alabel{r_1}
\ncarr{fke3}{c3}
\alabel{r_2}
}
\vspace{0.2cm}
\end{tabular}

It is a striking fact that two non-trivial path equivalences  will hold between paths constructed from these edges
in that both the diagram
\begin{tabular}{ c c c}
\footnotesize{
$
\begin{array}{cp{0.75cm}c}
   \Rnode{t}{t}       & &              \\[1.2cm]   
	 \Rnode{fk}{fk}     & &              \\[1.2cm] 
	 \Rnode{fke}{fke}   & & \Rnode{c}{c} \\[0cm]
							        & &               % horizontal spece needed    
\end{array}
$
\ncarr{fk}{t} 
\alabel{p_f}
\ncarr{fke}{c}
\blabel{r_1}
\ncarr{fke}{fk}
\alabel{p_e}
\ncarr{c}{t}
\blabel{p_c}
}
&and the diagram&
{\footnotesize
$
\begin{array}{cp{0.75cm}c}
   \Rnode{fk}{fk}     & & \Rnode{t}{t} \\[1.2cm]     
	 \Rnode{fke}{fke}   & & \Rnode{c}{c}
\end{array}
$
\ncarr{fk}{t} 
\alabel{r_0}
\ncarr{fke}{c}
\blabel{r_2}
\ncarr{fke}{fk}
\alabel{p_e}
\ncarr{c}{t}
\blabel{p_c}
}  \ \ will commute.
\end{tabular}
Path equivalence constraints (aka commutivity constraints) can therefore be found right at the heart of the relational model of data. Despite this, to my knowledge, this type of constraint  is absent from relational data theory and this  despite the fact, as mentioned above, that they have a direct bearing on the construction of schemas in third normal form.
The discussion in Shlaer and Lang \cite{Shlaer96} is an exception.

\section{The Dry Run  -- Data Specification as Presentation of Category}
\note
In this dry run -- data specification as presentation of category i.e. as linear sketch \cite{BarrandWells}-- we will formulate 
definitions of maximal constrainedness, commutivity constraint, functional dependency and referential inclusion dependency
and we will define what it means for such a commutivity constraint, functional dependency or  referential inclusion dependency to be represented in such data specifications.

\note
This dry run with its overtly simplified notion of data specification is worthwhile in that   it establishes some starter definitions which in further work we can   subsequently develop to be applicable to more fully elaborated notions.

\note 
This dry run establishes a pattern that we will follow later in consideration of more fully elaborated 
definitions of 
data specifications that we follow up with -- $\Po$-enriched categories, categories with products and others. 
You may also consider that the definitions given in this dry run are embryonic precursors to equivalent relational definitions.

\note
We will show that from these definitions it follows that if a data specification is maximally constrained to a
requirement then  all commutivity constraints,  functional dependencies and referential inclusion dependencies arising from the requirement are represented in the data specification.

\subsection {Definitions}
\subsubsection{Maximal Constrainedness}
Maximum constrainedness, as mentioned above, is a property of the category $\catc$ generated by the presentation  rather than of the presentation itself and is defined  relative to a requirement $\reqtc$ by which we mean a set of 
instances where each instance is a functor $D$, $D: \catc \morph \Fin$. In what follows, therefore,  by a requirement $\reqtc$ for category $\catc$ we mean a set  $\reqtc \subseteq | \Fin^{\catc} |$. 

Consider, a theory usually has some slack by which we mean that it has structurally compliant instances that are not part of the given requirement.  The definition of maximal constrainedness is to say that a theory is maximally constrained to its requirement if there is no way of extending the theory so as to rule out possible structurally compliant instances that are not part of the requirement (i.e. to rule out slack) whilst remaining consistent with the requirement.

The definition now follows, preceded by an auxiliary definition.
\begin{definition}
If $\catc$ is a category and $\reqtc$ is a requirement for $\catc$,  if $I: \catc \morph \catcp$ is a functor then say that $I$ is \term{consistent with} requirement $\reqtc$ iff for all instances $D \in \reqtc$ there exists a functor $D':\catcp \morph \Fin$ such that $I \circ D'=D$.
\end{definition}
\begin{definition}
If $\catc$ is a category and $\reqtc$ is a requirement for $\catc$ then $\catc$ is \term{maximally constrained} to the requirement $\reqtc$ iff for all categories $\catcp$ and for all functors $I:\catc \morph \catcp$ that are consistent with $\reqtc$, for all functors $F: \catc \morph \Fin$  there exists an $F' : \catcp \morph \Fin$ such that $I \circ F'=F$.
\end{definition}

\subsubsection{Functional Dependency}
\begin{definition}
If $\catc$ is a category and $\reqtc$ is a set of instances and if
$
\begin{array}{c p{0.5cm} c  }
             &&   \Rnode{b}{b} \\[0.01cm]
\Rnode{a}{a} &&                \\[0.01cm] 
             &&   \Rnode{c}{c}         
\end{array} 
$
\ncarr{a}{b}
\alabel{f}
\ncarr{a}{c}
\blabel{g}
in $\catc$ then there is a  \term{functional dependency} of $g$ on $f$ with respect to $\tuple{\catc,\reqtc}$ iff
there is a family of functions $H_D)_{D \in \reqtc}$ such that 
in each instance $D$, $H_D$ is a unique function $H_D: D(a) \morph D(b)$, such that $D(f) \circ H_D = D(g)$. 
If there is such a functional dependency then we say that $\fundep{H}{f}{g}$ with respect to $\tuple{\catc,\reqtc}$.
\end{definition}

Our use of the $\morph$ notation for functional dependencies here is coming from relational database theory where it is usual to represent such a functional dependency as we have here by asserting that 
$$
f \morph g
$$
Note that this use of an $\morph$ notation is independent of our use of $\morph$ as a morphism of a category 
or, for that matter, as an edge in a presentation. Neither are we alluding to a bicategory structure. We have two distinct uses for $\morph$ (three if you distinguish arrows in presentations from arrows in categories). Any particular use will be unambiguous in context.

\begin{definition}
If $\catc$ is a category and $\reqtc$ is a set of instances and if
$
\begin{array}{c p{0.5cm} c  }
             &&   \Rnode{b}{b} \\[0.01cm]
\Rnode{a}{a} &&                \\[0.01cm] 
             &&   \Rnode{c}{c}         
\end{array} 
$
\ncarr{a}{b}
\alabel{f}
\ncarr{a}{c}
\blabel{g}
in $\catc$ 
and if there is a functional dependency $\fundep{H}{f}{g}$ then say that 
the functional dependency $H$ is \term{represented} in $\catc$ 
iff there exists a morphism $h:b \morph c$ in $\catc$ such that for each instance $D \in \reqtc$, $D(h)=H_D$.
\end{definition}

\subsubsection{Referential Inclusion Dependency}
\begin{definition}
If $\catc$ is a category and $\reqtc$ is a set of instances and if
$
\begin{array}{c p{0.25cm} c  p{0.25cm} c }
             &&   \Rnode{b1}{b_1} &&              \\[0.4cm]
\Rnode{a}{a} &&                   && \Rnode{c}{c} \\[0.4cm]
             &&   \Rnode{bn}{b_n} &&              
\end{array} 
$
\ncarr{a}{b1}
\alabel{f_1}
\ncarr{c}{b1}
\blabel{q_1} 
\ncarr{a}{bn}
\blabel{f_n}
\ncarr{c}{bn}
\alabel{q_n}
in $\catc$, then a \term{referential inclusion dependency (in sense (1))} $I$, written $a[f_1,...f_n] \overset{I}{\subseteq} c[q_1,..q_n]$, is a family of functions $I_D)_{D \in \reqtc}$
such that each instance $D \in \reqtc$ $I_D$ is a unique function $I_D : D(c) \morph D(a)$ such that
$I_D \circ D(q_i) = D(f_i)$.
\end{definition}

\begin{definition}
If $\catc$ is a category and $\reqtc$ is a set of instances and if
$
\begin{array}{c p{0.25cm} c  p{0.25cm} c }
             &&   \Rnode{b1}{b_1} &&              \\[0.4cm]
\Rnode{a}{a} &&                   && \Rnode{c}{c} \\[0.4cm]
             &&   \Rnode{bn}{b_n} &&              
\end{array} 
$
\ncarr{a}{b1}
\alabel{f_1}
\ncarr{c}{b1}
\blabel{q_1} 
\ncarr{a}{bn}
\blabel{f_n}
\ncarr{c}{bn}
\alabel{q_n}
in $\catc$ and if $a[f_1,...f_n] \overset{I}{\subseteq} c[q_1,..q_n]$ is a referential inclusion dependency
with respect  to $\tuple{\catc,\reqtc}$ then say that the inclusion dependency $I$ is \term{represented} in $\catc$
iff there exists a morphism $i:a \morph c$ in $\catc$ such that in each instance $D \in \reqtc$, $D(i) = I_D$. 
\end{definition}

\subsection{Representation Lemmas}

The most immediate consequence of this definition is given by the next lemma.
\begin{lemma}
If $\catc$ is a locally finite category and $\reqtc$ is a set of instances  and $\catc$ is 
\term{maximally constrained} to the requirement $\reqtc$ then
for all diagrams
$
\rule[-0.3cm]{0pt}{0.9cm} %to add vertical space of diagram -- based on lowering diagram 0.3cm and heght 0.9cm
                            % change thickness from 0pt to 1 pt to debug
\begin{array}{c p{0.5cm} c  }
 \Rnode{a}{a}            &&   \Rnode{b}{b}
\end{array} 
$
\ncarc[nodesep=2pt,arcangle=10,offset=2pt]{->}{a}{b}
\alabel{f}
\ncarc[nodesep=2pt,arcangle=-10,offset=-2pt]{->}{a}{b}
\blabel{g}
in $\catc$,  if in all instances $D \in \reqtc$, $D(f)=D(g)$, 
then $f=g$ in $\catc$.
\end{lemma}
\begin{proof}
Suppose such a category  $\catc$  that  is 
\term{maximally constrained} to a requirement $\reqtc$
and suppose 
$
\rule[-0.3cm]{0pt}{0.9cm} %to add vertical space of diagram -- based on lowering diagram 0.3cm and heght 0.9cm
                            % change thickness from 0pt to 1 pt to debug
\begin{array}{c p{0.5cm} c  }
 \Rnode{a}{a}            &&   \Rnode{b}{b}
\end{array} 
$
\ncarc[nodesep=2pt,arcangle=10,offset=2pt]{->}{a}{b}
\alabel{f}
\ncarc[nodesep=2pt,arcangle=-10,offset=-2pt]{->}{a}{b}
\blabel{g}
in $\catc$. From sketch $S$ of $C$ we can construct a sketch $S'$ by formally adding a path equivalence $f=g$.
$S'$ generates a category $C'$ and an inclusion $I: \catc \morph \catcp$. Because $D(f) = D(g)$ in every instance $D \in \reqtc$
it follows that $I$ is consistent with $\reqtc$. Because $\catc$ is maximally constrained to $\reqtc$
and because $I: \catc \morph \catcp$ is consistent with $\reqtc$ it follows that he functor $Hom_{\catc}(a,-): \catc \morph \Fin$ 
can be extended to a functor $F: \catcp \morph \Fin$. Since $I(f)=I(g)$ in $\catcp$ then $F(I(f))=F(I(g))$. But $I \circ F
= hom(a,-)$ therefore we have that $Hom(a,f)=Hom(a,g)$ and, applying both sides to $id_a$, that $f=g$ in $C$ as required.
\end{proof}

\begin{lemma}
If $\catc$ is a locally finite category and $\reqtc$ is a set of instances  and $\catc$ is 
\term{maximally constrained} to the requirement $\reqtc$ then
all functional dependencies $\fundep{H}{f}{g}$  with respect to $\tuple{\catc,\reqtc}$ are represented in $\catc$.
\end{lemma}
\begin{proof}
Suppose such a category  $\catc$  that  is 
\term{maximally constrained} to a requirement $\reqtc$ and suppose
$
\begin{array}{c p{0.5cm} c  }
             &&   \Rnode{b}{b} \\[0.01cm]
\Rnode{a}{a} &&                \\[0.01cm] 
             &&   \Rnode{c}{c}         
\end{array} 
$
\ncarr{a}{b}
\alabel{f}
\ncarr{a}{c}
\blabel{g}
in $\catc$ 
and that there is a functional dependency $\fundep{H}{f}{g}$ with respect to $\tuple{\catc,\reqtc}$.

From sketch $S$ of $C$ we can construct a sketch $S'$ by formally adding a morphism $\qq{h}: b \morph c$
and path equivalence $f \circ \qq{h} = g$. Let $\catcp$ be the category generated by $S'$ and
let $I: C \morph C'$ be the inclusion functor generated by the inclusion of $S$ in $S'$. 
$I$ is consistent with $\reqtc$ since for and $D \in \reqtc$ we can extend $D$ to $D' :\catcp \morph \Fin$ by defining $D'(\qq{h})=D_H$.

Let the functor $F: \catc \morph \Fin$ be the coproduct $Hom_{\catc}(a,-) + Hom_{\catc}(a,-)$
in the functor category $Fin^{\catc}$ and label the injections $L$ and $R$, respectively so that
for each object $x$ of $\catc$ the diagram
\begin{center}
$
\begin{array}{c p{0.5cm} c p{0.5cm} c  }
\Rnode{h1}{Hom_{\catc}(a,x)}  &&\Rnode{Fx}{F(x)}  &&   \Rnode{h2}{Hom_{\catc}(a,x)}       
\end{array} 
$
\ncarr{h1}{Fx}
\alabel{L_x}
\ncarr{h2}{Fx}
\blabel{R_x}
\end{center}
is a coproduct in $\Fin$.

Now for each object $x$ of $\catc$, we define an equivalence relation $\sim_x$ on $F(x)$ by defining,
for $k_1,k_2:a \morph x$ in $\catc$,
\begin{align*}
L_x(k_1) \sim_x R_x(k_2) & \mbox{ iff there exists $k:b \morph x$ in $\catc$ such that $k_1 = f \circ k = k_2$,}\\
L_x(k_1) \sim_x L_x(k_2) & \mbox{ iff $k_1 = k_2$,} \\
R_x(k_1) \sim_x R_x(k_2) & \mbox{ iff $k_1 = k_2$.} \\
\end{align*}
If $j: x_1 \morph x_2$ in $\catc$ and if $y_1,y_2 \in F(x_1)$ such that $y_1 \sim_{x_1} y_2$
then it follows easily by cases and from the definition of $\sim$ that $F(j)(y_1) \sim_{x_2} F(j)(y_2)$.
Therefore we can define a functor 
 $G: \catc \morph \Fin$  so that for any object $x$ of $\catc$
the set $G(x)$ is the quotient $F(x)/{\sim_x}$ and such that 
if $j: x_1 \morph x_2$ in $\catc$ and if $y \in F(x_1)$ then $G(j)([y])=[F(j)(y)]$.
With $G$ so defined then if $k: a \morph x_1$ and $j:x_1 \morph x_2$ in $\catc$
then  $G(j)([L(k)])=[L(k \circ j)]$ and $G(j)([R(k)])=[R(k \circ j)]$. 

Now that we have described the functors  $G: \catc \morph \Fin$ and $I:\catc \morph \catcp$ that is consistent with $\reqtc$
we can use the fact that $\catc$ is maximally constrained then $G$ extends to a functor 
$G' : \catcp \morph \Fin$. Since $f \circ \qq{h} = g$ in $\catcp$ then we have
 $G'(f) \circ G'(\qq{h}) = G'(g): G(a) \morph G(b)$ in $\Fin$.
But $[L_a(id_a)] \in G(a)$ and $[R_a(id_a)] \in G(a)$ and therefore
\begin{align*}
[L_c(g)]&= G'(g)([L_a(id_a)])              & & \mbox{by definition of $G'(g)=G(g)$}           \\
        &= G'(\qq{h}) (G'(f)([L_a(id_a)])) & & \mbox{since $G'(f) \circ G'(\qq{h}) = G'(g)$}  \\
				&= G'(\qq{h}) (G'([L_b(f)]))       & & \mbox{by definition of $G'(f)=G(f)$}           \\
				&= G'(\qq{h}) (G'([R_b(f)]))       & & \mbox{since $L_b(f) \sim R_b(f)$, by definition of $\sim$} \\
				&= G'(\qq{h}) (G'(f)([R_a(id_a)])) & & \mbox{by definition of $G'(f)=G(f)$}           \\
		    &= G'(g)([R_a(id_a)])              & & \mbox{since $G'(f) \circ G'(\qq{h}) = G'(g)$}  \\
				&= [R_c(g)]                        & & \mbox{by definition of $G'(g)=G(g)$}           \\
\end{align*}
Since $[L_c(g)]=[R_c(g)]$ then it follows that there exists $k:b \morph c$ in 
$\catc$ such that $f \circ k = g$ and we have shown as required that the function dependency
$\fundep{H}{f}{g}$ is represented in $\catc$.

\end{proof}

\begin{lemma}
\label{catincdsrepresented}
If $\catc$ is a locally finite category and $\reqtc$ is a set of instances  and $\catc$ is 
\term{maximally constrained} to the requirement $\reqtc$ then
every referential inclusion dependency with respect to $\tuple{\catc,\reqtc}$ is represented in $\catc$.
\end{lemma}
\begin{proof}
Suppose such  a category $\catc$ and  requirement $\reqtc$ 
 and suppose there is a referential inclusion dependency
$a[f_1,...f_n] \overset{I}{\subseteq} b[q_1,..q_n]$ with respect to $\tuple{\catc,\reqtc}$,
where
$
\begin{array}{c p{0.25cm} c  p{0.25cm} c }
             &&   \Rnode{b1}{b_1} &&              \\[0.4cm]
\Rnode{a}{a} &&                   && \Rnode{b}{b} \\[0.4cm]
             &&   \Rnode{bn}{b_n} &&              
\end{array} 
$
\ncarr{a}{b1}
\alabel{f_1}
\ncarr{b}{b1}
\blabel{q_1} 
\ncarr{a}{bn}
\blabel{f_n}
\ncarr{b}{bn}
\alabel{q_n}
in $\catc$, 

From sketch $S$ of $C$ we can construct a sketch $S'$ by formally adding a morphism $\qq{f}: a \morph c$
and path equivalences $\qq{f} \circ q_i = f_i$. Let $\catcp$ be the category generated by $S'$ and
let $I: C \morph C'$ be the inclusion functor generated by the inclusion of $S$ in $S'$. $I$ is consistent with $\reqtc$ since
each instance $D \in  \reqtc$ can be extended to a functor $D': \catcp \morph \Fin$ by defining $D'(\qq{f})=I_D$.

Since $\catc$ is locally finite then there is a functor $Hom_{\catc}(a,-): \catc \morph \Fin$ and since $\catc$ is maximally constrained and because $I$ is consistent with $\reqtc$ then there is a functor $F': C' \morph \Fin$
such that $I \circ F' = Hom_{\catc}(a,-)$. In particular we must have 
$F'(a)=Hom_{\catc}(a,a)$,
$F'(b)=Hom_{\catc}(a,b)$ and therefore $F'(\qq{f}):Hom_{\catc}(a,a) \morph Hom_{\catc}(a,b)$ which gives us
$F'(\qq{f})(id_a): a \morph b$ in $\catc$. 

We can show that $F'(\qq{f})(id_a)$ represents
the inclusion dependency $a[f_1,...f_n] \overset{I}{\subseteq} b[q_1,..q_n]$ by showing that for 
each $i$, $1 \leq i \leq n$, $F'(\qq{f})(id_a) \circ q_i = f_i$. This follows because we have defined
the sketch $S'$ so that in category $C'$ we have $\qq{f} \circ q_i = f_i$. From this it follows
that $F'(\qq{f}) \circ F'(q_i) = F'(f_i)$ i.e. $F'(\qq{f}) \circ Hom(a,q_i) = Hom(a,f_i)$. Applying left and right hand sides to $id_a$ we get $F'(\qq{f})(id_a) \circ q_i = f_i$, as required.
\end{proof}


\iffalse

\section{Direction of Travel}
Pointers direct. Graph data model? When serialised though. Transformations.


Type theory - dependent type theory. Category with distinguished morphisms. PCTE\\CAIS Contextual category. Dependency category.

\section*{Data Specification as Presentation of Category with  Monomorphisms}
\section*{Data Specification as Presentation of Category with Products and Monomorphisms}
\section*{Data Specification as Presentation of Category with Limits (and Monomorphisms)}
\section*{Data Specification as Presentation of $\Po$-enriched Category}
\fi
\bibliographystyle{alpha} 
\bibliography{../SharedBibliography/temp/bibliography}
\end{document}
