
\newenvironment{graph} % graph with key alongside
{
\begin{tabular}{c p{1cm}c}
}
{
\end{tabular}
}

\iffalse
Is a presentation of a category really a notion of data specification? 
Well, as we might specify data in an XML schema, or in IDL or in a relational schema, then it isn't. But as we might outline
data in a preliminary design of such, say like shown in this fragment 
$
\begin{array}{c p{0.05cm}c p{0.5cm}c}
                        & & \rule[-0.3cm]{0pt}{0.8cm}\Rnode{p}{p}roject& &             \\ [0.3cm]
    project-wo\Rnode{w}{rker} & &                   & &  \\ [0.3cm]     
                         & & \Rnode{e}{e}mployee      & &             \\ [0.6cm]     
                         & & \Rnode{dep}{d}ependent  & &             
\end{array}
\begin{arrows}
\ncarr{w}{p} 
\alabel{R_1}[0.5][-1]
\ncarr{w}{e} 
\blabel{R_2}[0.5][-1]
\ncarr{dep}{e} 
\alabel{S_0}
\end{arrows}
$,
then it might be.

It also might be \textit{after we take away detail} from a complete specification to achieve an abstraction. Thus we can recognise
occurrences of directed graphs within larger and fully detailed data specifications wherever we can find occurrences
of this diagram:
$$
\begin{array}{c p{0.25cm} c  p{0.25cm} c }
\Rnode{e}{e} &&                   && \Rnode{n}{n} \\[0.4cm]
\end{array}
$$
\Etme[20]{e}{n}
\alabel{src}[0.75]
\Etme[-20]{e}{n}
\blabel{tgt}[0.75]

I mention this  because Bachman in his 1969 paper \textit{Data Structure Diagrams} \cite{Bachman1969}
enthuses over multiple occurrences of this shape appearing in  a larger data specification\footnote{Though his notation is different and in particular his arrows are the reverse of ours.}. 
\subsubsection{Molecular Structure}
\subsubsection{Tabular Data}
\begin{graph}
$
\begin{array}{c p{0.25cm}c p{0.25cm}c}
             && \Rnode{t}{t}   &&              \\ [0.4cm]
\Rnode{r}{r} &&                && \Rnode{c}{c} \\ [0.4cm]     
             && \Rnode{d}{d} &&                    
\end{array}
\begin{arrows}
\ncarr{r}{t} 
\alabel{R_1}[0.5]%[-1]
\ncarr{c}{t} 
\blabel{R_2}[0.5]%[-1]
\ncarr{d}{r} 
\alabel{S_1}
\ncarr{d}{c}
\blabel{S_2} 
\end{arrows}
$
&&
\begin{key}
\keyentry{t} {table}  {a table of data}
\keyentry{r} {row}    {a row within a table}
\keyentry{c} {column} {a column within a table}                
\keyentry{d} {data}   {each data item is located in both a row and a column} 
\end{key}
\end{graph}



\subsubsection{Function Application}
In this example we give a simplified description of data representing a computer program
written in some modular programming language.\\ 
\begin{graph}
$
\begin{array}{c p{0.25cm}c p{0.25cm}c}
               && \Rnode{abs}{p} &&               \\ [0.7cm]  
               && \Rnode{T}{pm} &&               \\ [0.7cm]    
\Rnode{TL}{fc} &&               && \Rnode{TR}{f} \\ [0.8cm] 
\Rnode{BL}{ap} &&               && \Rnode{BR}{fp}   
\end{array}
\begin{arrows}
\ncarr{T}{abs} 
\alabel{R_0}
\ncarr{TL}{T} 
\alabel{R_1}
\ncarr{TR}{T} 
\blabel{R_2}
\ncarr{TL}{TR} 
\alabel{S_1}
\ncarr{BL}{BR} 
\blabel{S_2}
\ncarr{BL}{TL} 
\alabel{Q_1}
\ncarr{BR}{TR}
\blabel{Q_2} 
\end{arrows}
$
&&
\begin{key}
\keyentry{p}  {program}             {a computer program}
\keyentry{pm} {program module}      {part of a computer program ($R_0$)}
\keyentry{fc} {function call}       {point of use of a function in a program}
\keyentry{ap} {actual parameter}    {supply of a value to the formal parameter ($S_2$) of a function in a function call ($Q_1$)}
\keyentry{f } {function}            {the definition of a function within a program}                
\keyentry{fp} {formal parameter}    {defined for a function in its definition} 
\end{key} 
\end{graph} \\
Subject to path equivalences: 
\begin{equation}
\label{programquivalence1}
Q_1\circ S_1 \sim S_2 \circ S_1
\end{equation}
\begin{equation}
\label{programequivalence2}
R_1 \circ R_0 \sim S_1 \circ R_2 \circ R_0
\end{equation}

I ask the reader to interpret these path equivalences and what they say about the programming language. 
In practice we would also specify that functions and possibly formal parameters are named and that 
to each formal parameter there should correspond at most one actual parameter within any given function call.
This means that the pair of functions 
\nudgeup{0.9cm}\nudgedown{0.65cm} \sourcediag{D(ap)}{D(fc)}{D(fp)}{D(Q_1)}{D(S_2)}
will be jointly injective 
i.e. comprise a mono-source\footnote{Terminology that is used in the context of data specifications in Piersenns.} in  category $\Fin$.
Note also that in a programming language which does not support default values for formals and as a cosnequence
actual parameter values must be supplied for all formals (in a programming langauge which does not support default values for parameters) in every function call then in every instance $D$ of a valid program the diagram
\begin{displaymath}
\begin{array}{c p{0.25cm}c p{0.25cm}c} 
                  &&               &&                   \\[0.3cm]
\Rnode{TL}{D(fc)} &&               && \Rnode{TR}{D(f)}  \\[0.8cm] 
\Rnode{BL}{D(ap)} &&               && \Rnode{BR}{D(fp)} \\[0.3cm]
\end{array}
\begin{arrows}
\ncarr{TL}{TR} 
\alabel{D(S_1)}
\ncarr{BL}{BR} 
\blabel{D(S_2)}
\ncarr{BL}{TL} 
\alabel{D(Q_1)}
\ncarr{BR}{TR}
\blabel{D(Q_2)} 
\end{arrows}
\end{displaymath}
will be a pullback diagram in $\Fin$. Representation of pullbacks in data specifications will be a subject of a future note.
Fagin uses the term \term{projection-join dependency} in such situations and his projection-join normal form states when the such
 dependency is justified in a data specification. 
\fi
\subsubsection{Relational Meta-Model}
A data specification that describes the relational model of data (in other words, the data specification that is the relational meta-model) when viewed abstractly as a directed graph
include nodes representing the concepts of table ($t$) , column ($c$), foreign key constraint ($fk$) and foreign key element ($fke$) as well as others
\iffalse
\raisebox{-0.7cm}
{\footnotesize
\begin{tabular}{cp{0.75cm}cp{13cm}}
                 &$t$&    &  table  \\ [0.1cm]
                 &$c$&    & column  \\ [0.1cm]
                &$fk$&    & foreign key -- consists of one or more foreign key elements \\[0.1cm]
               &$fke$&    & foreign key element --  . 
\end{tabular}	
}
\vspace{0.25cm}
\fi
and  also includes the following edges:	\\
\begin{tabular}{p{1cm} c}
&
{\footnotesize
$		
\begin{array}{cp{0.75cm}cp{13cm}}	
                                                                  \\			
\Rnode{c}{c}      && \Rnode{t}{t}   & the parent table of a column\\[0.2cm]   
\Rnode{fk}{fk}    && \Rnode{t2}{t}  & the parent table of a foreign key\\[0.2cm] 
\Rnode{fke}{fke}  && \Rnode{fk2}{fk}& the foreign key a foreign key element is part of\\[0.2cm]  
\Rnode{fk3}{fk}   && \Rnode{t3}{t}  & the table that the foreign key defines a reference to\\[0.2cm]     
\Rnode{fke2}{fke} && \Rnode{c2}{c}  & the referencing column identified by the foreign key element\\[0.2cm]     
\Rnode{fke3}{fke} && \Rnode{c3}{c}  & the referred to column identified by the foreign key element         
\end{array}
$
\ncarr{c}{t}
\alabel{p_c}
\ncarr{fk}{t2} 
\alabel{p_f}
\ncarr{fke}{fk2}
\alabel{p_e}
\ncarr{fk3}{t3} 
\alabel{r_0}
\ncarr{fke2}{c2}
\alabel{r_1}
\ncarr{fke3}{c3}
\alabel{r_2}
}
\vspace{0.2cm}
\end{tabular}

as follows:

\begin{graph}
$
\begin{array}{p {1cm} c p{0.9cm} c p{0.7cm} c}
&              && \Rnode{abs}{rdb}  &&         \\[0.7cm]
&              && \Rnode{T}{t}      &&         \\[0.75cm]
&\Rnode{ML}{c} && \Rnode{MC}{pke}   &&  \Rnode{MR}{fk}  \\[0.7cm]
&              &&                   &&  \Rnode{BR}{fke}  \\[1.3cm]
\end{array}
\begin{arrows}
% composition
\ncarr{T}{abs}
\blabel{S_0}
\ncarr{ML}{T}
\alabel{S_1}[0.4]
\ncarr{MC}{T}
\blabel{S_2}[0.4]
\ncarr{MR}{T}
\blabel{S_3}[0.4]
\ncarr{BR}{MR}
\blabel{S_4}
% reference
\ncarr[20]{MC}{ML}
\alabel{R_1}
\ncangle[angleA=180,linearc=0.1]{->}{BR}{MC}
\alabel{R_?}
\ncloop[nodesepA=4pt,angleB=180,nodesepB=3pt,loopsize=-2.0cm,armA=0.6cm,armB=2.7cm,linearc=0.2cm]{->}{MR}{T}
\naput[npos=2.5,labelsep=2pt]{\footnotesize $R_2$}
\ncloop[nodesepA=4pt,angleB=180,nodesepB=3pt,loopsize=-0.5cm,armA=0.3cm,armB=0.4cm,linearc=0.15cm]{->}{BR}{ML}
\nbput[npos=2.5,labelsep=2pt]{\footnotesize $R_3$}
\end{arrows}
$
&&
\begin{key}
\keyentry{rdb}{relational database}{}
\keyentry{t}{table}{a table within a relational database($S_0$)}
\keyentry{c}{column}{a column of a table ($S_1$)}
\keyentry{pke}{primary key element}{identifies a column ($R_1$)to be part of the primary key of a table}
\keyentry{fk}{foreign key}{implements a relationship between one table ($S_3$) and another ($R_2$)}
\keyentry{fke}{foreign key element}{associates a referencing column ($R?$) and a referred to column ($R_3$)}
\end{key}
\end{graph}

It is a striking fact that two non-trivial path equivalences  
will hold between paths constructed from these edges in that both the diagram
\begin{tabular}{ c c c}
\footnotesize{
$
\begin{array}{cp{0.75cm}c}
   \Rnode{t}{t}       & &              \\[1.2cm]   
	 \Rnode{fk}{fk}     & &              \\[1.2cm] 
	 \Rnode{fke}{fke}   & & \Rnode{c}{c} \\[0cm]
							        & &               % horizontal spece needed    
\end{array}
$
\ncarr{fk}{t} 
\alabel{p_f}
\ncarr{fke}{c}
\blabel{r_1}
\ncarr{fke}{fk}
\alabel{p_e}
\ncarr{c}{t}
\blabel{p_c}
}
&and the diagram&
{\footnotesize
$
\begin{array}{cp{0.75cm}c}
   \Rnode{fk}{fk}     & & \Rnode{t}{t} \\[1.2cm]     
	 \Rnode{fke}{fke}   & & \Rnode{c}{c}
\end{array}
$
\ncarr{fk}{t} 
\alabel{r_0}
\ncarr{fke}{c}
\blabel{r_2}
\ncarr{fke}{fk}
\alabel{p_e}
\ncarr{c}{t}
\blabel{p_c}
}  \ \ will commute.
\end{tabular}
Path equivalence constraints (aka commutivity constraints) can therefore be found right at the heart of the relational model of data. Despite this, to my knowledge, this type of constraint  is absent from relational data theory and this  despite the fact, as mentioned above, that they have a direct bearing on the construction of schemas in third normal form.
The discussion in Shlaer and Lang \cite{Shlaer96} is an exception.